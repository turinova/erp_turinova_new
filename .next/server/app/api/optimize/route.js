/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/optimize/route";
exports.ids = ["app/api/optimize/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Foptimize%2Froute&page=%2Fapi%2Foptimize%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Foptimize%2Froute.ts&appDir=%2FVolumes%2FT7%2Ferp_turinova_new%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FVolumes%2FT7%2Ferp_turinova_new&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Foptimize%2Froute&page=%2Fapi%2Foptimize%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Foptimize%2Froute.ts&appDir=%2FVolumes%2FT7%2Ferp_turinova_new%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FVolumes%2FT7%2Ferp_turinova_new&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Volumes_T7_erp_turinova_new_src_app_api_optimize_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/optimize/route.ts */ \"(rsc)/./src/app/api/optimize/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/optimize/route\",\n        pathname: \"/api/optimize\",\n        filename: \"route\",\n        bundlePath: \"app/api/optimize/route\"\n    },\n    resolvedPagePath: \"/Volumes/T7/erp_turinova_new/src/app/api/optimize/route.ts\",\n    nextConfigOutput,\n    userland: _Volumes_T7_erp_turinova_new_src_app_api_optimize_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZvcHRpbWl6ZSUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGb3B0aW1pemUlMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZvcHRpbWl6ZSUyRnJvdXRlLnRzJmFwcERpcj0lMkZWb2x1bWVzJTJGVDclMkZlcnBfdHVyaW5vdmFfbmV3JTJGc3JjJTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZWb2x1bWVzJTJGVDclMkZlcnBfdHVyaW5vdmFfbmV3JmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUErRjtBQUN2QztBQUNxQjtBQUNVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQXNEO0FBQzlEO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQzBGOztBQUUxRiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVm9sdW1lcy9UNy9lcnBfdHVyaW5vdmFfbmV3L3NyYy9hcHAvYXBpL29wdGltaXplL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9vcHRpbWl6ZS9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL29wdGltaXplXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9vcHRpbWl6ZS9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Wb2x1bWVzL1Q3L2VycF90dXJpbm92YV9uZXcvc3JjL2FwcC9hcGkvb3B0aW1pemUvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICB3b3JrQXN5bmNTdG9yYWdlLFxuICAgICAgICB3b3JrVW5pdEFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Foptimize%2Froute&page=%2Fapi%2Foptimize%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Foptimize%2Froute.ts&appDir=%2FVolumes%2FT7%2Ferp_turinova_new%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FVolumes%2FT7%2Ferp_turinova_new&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/optimize/route.ts":
/*!***************************************!*\
  !*** ./src/app/api/optimize/route.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_optimization_algorithms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/optimization/algorithms */ \"(rsc)/./src/lib/optimization/algorithms.ts\");\n/* harmony import */ var _lib_optimization_cutCalculations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/optimization/cutCalculations */ \"(rsc)/./src/lib/optimization/cutCalculations.ts\");\n// Main Optimization API Route - Node.js version of PHP optimization\n// Handles material optimization requests from the frontend\n\n\n\n// CORS headers\nconst corsHeaders = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization'\n};\nasync function OPTIONS() {\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n        status: 200,\n        headers: corsHeaders\n    });\n}\nasync function POST(request) {\n    const apiStartTime = performance.now();\n    try {\n        // Get the request data from the frontend\n        const input = await request.json();\n        if (!input || !Array.isArray(input.materials)) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Invalid request data - missing materials array'\n            }, {\n                status: 400,\n                headers: corsHeaders\n            });\n        }\n        console.log(`[API] Processing optimization request with ${input.materials.length} materials`);\n        console.time('[API] Total Optimization Time');\n        // Process each material from the request\n        const results = [];\n        for (const materialData of input.materials){\n            const materialStartTime = performance.now();\n            const materialId = materialData.id;\n            const materialName = materialData.name;\n            const parts = materialData.parts;\n            const board = materialData.board;\n            const params = materialData.params;\n            console.log(`[API] Processing material: ${materialName} (${materialId}) - ${parts.length} parts`);\n            // Process panels for this material - expand by quantity\n            console.time(`[API] Process Panels: ${materialName}`);\n            const panels = (0,_lib_optimization_algorithms__WEBPACK_IMPORTED_MODULE_1__.processPanelsForMaterial)(parts, false); // grain_direction not in current data structure\n            console.timeEnd(`[API] Process Panels: ${materialName}`);\n            // Get board dimensions\n            const boardWidth = board.w_mm;\n            const boardHeight = board.h_mm;\n            const trimLeft = board.trim_left_mm ?? 0;\n            const trimRight = board.trim_right_mm ?? 0;\n            const trimTop = board.trim_top_mm ?? 0;\n            const trimBottom = board.trim_bottom_mm ?? 0;\n            const kerfSize = params.kerf_mm ?? 3;\n            // CRITICAL: Swap board dimensions to place panels along the LENGTH side (longer dimension)\n            // This matches the PHP logic exactly\n            const boardWidthSwapped = boardHeight; // 2070 (now treated as width for horizontal placement)\n            const boardHeightSwapped = boardWidth; // 2800 (now treated as height for vertical stacking)\n            // Calculate usable board dimensions after trim\n            const { usableWidth, usableHeight } = (0,_lib_optimization_algorithms__WEBPACK_IMPORTED_MODULE_1__.calculateUsableBoardDimensions)(boardWidthSwapped, boardHeightSwapped, trimLeft, trimRight, trimTop, trimBottom);\n            // Use the guillotine cutting algorithm\n            console.time(`[API] Guillotine Algorithm: ${materialName}`);\n            const bins = (0,_lib_optimization_algorithms__WEBPACK_IMPORTED_MODULE_1__.guillotineCutting)(panels, usableWidth, usableHeight, kerfSize);\n            console.timeEnd(`[API] Guillotine Algorithm: ${materialName}`);\n            console.log(`[API] ${materialName}: Created ${bins.length} bins for ${panels.length} panels`);\n            // Convert to response format - process ALL boards\n            const placements = [];\n            const unplaced = [];\n            const placedPanelIds = [];\n            const boardCutLengths = {};\n            // Process all bins (all boards)\n            console.time(`[API] Process Bins: ${materialName}`);\n            if (bins.length > 0) {\n                for(let binIndex = 0; binIndex < bins.length; binIndex++){\n                    const bin = bins[binIndex];\n                    // Calculate actual cut length using the sophisticated algorithm\n                    const boardCutLength = (0,_lib_optimization_cutCalculations__WEBPACK_IMPORTED_MODULE_2__.processBin)(bin, trimLeft, trimRight, trimTop, trimBottom);\n                    boardCutLengths[binIndex + 1] = boardCutLength;\n                    for (const rect of bin.usedRectangles){\n                        // Find the original panel data that matches this rectangle\n                        let originalPanel = null;\n                        let originalIndex = -1;\n                        // Find which part this panel came from by checking dimensions\n                        for(let i = 0; i < parts.length; i++){\n                            const part = parts[i];\n                            const quantity = part.qty ?? 1;\n                            // Check if dimensions match (accounting for possible rotation)\n                            // Note: w_mm = hosszúság, h_mm = szélesség in the API request\n                            // Rectangle constructor: new Rectangle($part['h_mm'], $part['w_mm'], ...)\n                            // So rect->width = h_mm (szélesség), rect->height = w_mm (hosszúság)\n                            if (part.h_mm === rect.width && part.w_mm === rect.height || part.h_mm === rect.height && part.w_mm === rect.width) {\n                                // Count how many of this part type we've already placed\n                                let alreadyPlacedCount = 0;\n                                for (const placedId of placedPanelIds){\n                                    if (placedId.startsWith(part.id)) {\n                                        alreadyPlacedCount++;\n                                    }\n                                }\n                                // If we haven't placed all quantities of this part yet\n                                if (alreadyPlacedCount < quantity) {\n                                    originalPanel = part;\n                                    originalIndex = i;\n                                    break;\n                                }\n                            }\n                        }\n                        if (originalPanel) {\n                            let instanceNumber = 1;\n                            for (const placedId of placedPanelIds){\n                                if (placedId.startsWith(originalPanel.id)) {\n                                    instanceNumber++;\n                                }\n                            }\n                            placements.push({\n                                id: `${originalPanel.id}-${instanceNumber}`,\n                                x_mm: rect.x + trimLeft,\n                                y_mm: rect.y + trimTop,\n                                w_mm: rect.width,\n                                h_mm: rect.height,\n                                rot_deg: 0,\n                                board_id: binIndex + 1\n                            });\n                            placedPanelIds.push(`${originalPanel.id}-${instanceNumber}`);\n                        }\n                    }\n                }\n            }\n            console.timeEnd(`[API] Process Bins: ${materialName}`);\n            // Mark remaining panels as unplaced\n            for(let i = 0; i < parts.length; i++){\n                const part = parts[i];\n                const quantity = part.qty ?? 1;\n                // Count how many of this part type were placed\n                let placedCount = 0;\n                for (const placedId of placedPanelIds){\n                    if (placedId.startsWith(part.id)) {\n                        placedCount++;\n                    }\n                }\n                // Add unplaced instances\n                for(let j = placedCount; j < quantity; j++){\n                    unplaced.push({\n                        id: `${part.id}-${j + 1}`,\n                        w_mm: part.w_mm,\n                        h_mm: part.h_mm,\n                        reason: 'No space available'\n                    });\n                }\n            }\n            // Calculate metrics\n            let totalUsedArea = 0;\n            for (const placement of placements){\n                totalUsedArea += placement.w_mm * placement.h_mm;\n            }\n            const boardArea = boardWidthSwapped * boardHeightSwapped;\n            const totalBoardArea = boardArea * bins.length;\n            const wastePercentage = totalBoardArea > 0 ? (totalBoardArea - totalUsedArea) / totalBoardArea * 100 : 0;\n            // Calculate total cut length\n            const totalCutLength = Object.values(boardCutLengths).reduce((sum, length)=>sum + length, 0);\n            // Add result for this material\n            results.push({\n                material_id: materialId,\n                material_name: materialName,\n                placements: placements,\n                unplaced: unplaced,\n                metrics: {\n                    used_area_mm2: totalUsedArea,\n                    board_area_mm2: totalBoardArea,\n                    waste_pct: Math.round(wastePercentage * 100) / 100,\n                    placed_count: placements.length,\n                    unplaced_count: unplaced.length,\n                    boards_used: bins.length,\n                    total_cut_length_mm: totalCutLength\n                },\n                board_cut_lengths: boardCutLengths,\n                debug: {\n                    board_width: boardWidthSwapped,\n                    board_height: boardHeightSwapped,\n                    usable_width: usableWidth,\n                    usable_height: usableHeight,\n                    bins_count: bins.length,\n                    panels_count: panels.length\n                }\n            });\n            const materialDuration = performance.now() - materialStartTime;\n            console.log(`[API] ✅ ${materialName} complete in ${materialDuration.toFixed(2)}ms (${bins.length} boards, ${placements.length} placements)`);\n        }\n        console.timeEnd('[API] Total Optimization Time');\n        const totalDuration = performance.now() - apiStartTime;\n        console.log(`[API] ✅ All materials optimized in ${totalDuration.toFixed(2)}ms`);\n        // Return results array directly as expected by OptiClient\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(results, {\n            headers: corsHeaders\n        });\n    } catch (error) {\n        console.error('Optimization error:', error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            status: 'error',\n            message: 'Optimization service error',\n            error: error instanceof Error ? error.message : 'Unknown error',\n            timestamp: new Date().toISOString()\n        }, {\n            status: 500,\n            headers: corsHeaders\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFZO0lBRXhDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1Q3L2VycF90dXJpbm92YV9uZXcvc3JjL2FwcC9hcGkvb3B0aW1pemUvcm91dGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFpbiBPcHRpbWl6YXRpb24gQVBJIFJvdXRlIC0gTm9kZS5qcyB2ZXJzaW9uIG9mIFBIUCBvcHRpbWl6YXRpb25cbi8vIEhhbmRsZXMgbWF0ZXJpYWwgb3B0aW1pemF0aW9uIHJlcXVlc3RzIGZyb20gdGhlIGZyb250ZW5kXG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBndWlsbG90aW5lQ3V0dGluZywgcHJvY2Vzc1BhbmVsc0Zvck1hdGVyaWFsLCBjYWxjdWxhdGVVc2FibGVCb2FyZERpbWVuc2lvbnMgfSBmcm9tICdAL2xpYi9vcHRpbWl6YXRpb24vYWxnb3JpdGhtcyc7XG5pbXBvcnQgeyBwcm9jZXNzQmluIH0gZnJvbSAnQC9saWIvb3B0aW1pemF0aW9uL2N1dENhbGN1bGF0aW9ucyc7XG5pbXBvcnQgdHlwZSB7IE9wdGltaXphdGlvblJlcXVlc3QsIE9wdGltaXphdGlvblJlc3VsdCwgUGxhY2VtZW50LCBVbnBsYWNlZFBhcnQgfSBmcm9tICdAL3R5cGVzL29wdGltaXphdGlvbic7XG5cbi8vIENPUlMgaGVhZGVyc1xuY29uc3QgY29yc0hlYWRlcnMgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nOiAnKicsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJzogJ0dFVCwgUE9TVCwgT1BUSU9OUycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZSwgQXV0aG9yaXphdGlvbicsXG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gT1BUSU9OUygpIHtcbiAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDIwMCwgaGVhZGVyczogY29yc0hlYWRlcnMgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnN0IGFwaVN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gIFxuICB0cnkge1xuICAgIC8vIEdldCB0aGUgcmVxdWVzdCBkYXRhIGZyb20gdGhlIGZyb250ZW5kXG4gICAgY29uc3QgaW5wdXQgPSBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcbiAgICBcbiAgICBpZiAoIWlucHV0IHx8ICFBcnJheS5pc0FycmF5KGlucHV0Lm1hdGVyaWFscykpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0ludmFsaWQgcmVxdWVzdCBkYXRhIC0gbWlzc2luZyBtYXRlcmlhbHMgYXJyYXknIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAsIGhlYWRlcnM6IGNvcnNIZWFkZXJzIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtBUEldIFByb2Nlc3Npbmcgb3B0aW1pemF0aW9uIHJlcXVlc3Qgd2l0aCAke2lucHV0Lm1hdGVyaWFscy5sZW5ndGh9IG1hdGVyaWFsc2ApO1xuICAgIGNvbnNvbGUudGltZSgnW0FQSV0gVG90YWwgT3B0aW1pemF0aW9uIFRpbWUnKVxuXG4gICAgLy8gUHJvY2VzcyBlYWNoIG1hdGVyaWFsIGZyb20gdGhlIHJlcXVlc3RcbiAgICBjb25zdCByZXN1bHRzOiBPcHRpbWl6YXRpb25SZXN1bHRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBtYXRlcmlhbERhdGEgb2YgaW5wdXQubWF0ZXJpYWxzKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBjb25zdCBtYXRlcmlhbElkID0gbWF0ZXJpYWxEYXRhLmlkO1xuICAgICAgY29uc3QgbWF0ZXJpYWxOYW1lID0gbWF0ZXJpYWxEYXRhLm5hbWU7XG4gICAgICBjb25zdCBwYXJ0cyA9IG1hdGVyaWFsRGF0YS5wYXJ0cztcbiAgICAgIGNvbnN0IGJvYXJkID0gbWF0ZXJpYWxEYXRhLmJvYXJkO1xuICAgICAgY29uc3QgcGFyYW1zID0gbWF0ZXJpYWxEYXRhLnBhcmFtcztcblxuICAgICAgY29uc29sZS5sb2coYFtBUEldIFByb2Nlc3NpbmcgbWF0ZXJpYWw6ICR7bWF0ZXJpYWxOYW1lfSAoJHttYXRlcmlhbElkfSkgLSAke3BhcnRzLmxlbmd0aH0gcGFydHNgKTtcblxuICAgICAgLy8gUHJvY2VzcyBwYW5lbHMgZm9yIHRoaXMgbWF0ZXJpYWwgLSBleHBhbmQgYnkgcXVhbnRpdHlcbiAgICAgIGNvbnNvbGUudGltZShgW0FQSV0gUHJvY2VzcyBQYW5lbHM6ICR7bWF0ZXJpYWxOYW1lfWApXG4gICAgICBjb25zdCBwYW5lbHMgPSBwcm9jZXNzUGFuZWxzRm9yTWF0ZXJpYWwocGFydHMsIGZhbHNlKTsgLy8gZ3JhaW5fZGlyZWN0aW9uIG5vdCBpbiBjdXJyZW50IGRhdGEgc3RydWN0dXJlXG4gICAgICBjb25zb2xlLnRpbWVFbmQoYFtBUEldIFByb2Nlc3MgUGFuZWxzOiAke21hdGVyaWFsTmFtZX1gKVxuXG4gICAgICAvLyBHZXQgYm9hcmQgZGltZW5zaW9uc1xuICAgICAgY29uc3QgYm9hcmRXaWR0aCA9IGJvYXJkLndfbW07XG4gICAgICBjb25zdCBib2FyZEhlaWdodCA9IGJvYXJkLmhfbW07XG4gICAgICBjb25zdCB0cmltTGVmdCA9IGJvYXJkLnRyaW1fbGVmdF9tbSA/PyAwO1xuICAgICAgY29uc3QgdHJpbVJpZ2h0ID0gYm9hcmQudHJpbV9yaWdodF9tbSA/PyAwO1xuICAgICAgY29uc3QgdHJpbVRvcCA9IGJvYXJkLnRyaW1fdG9wX21tID8/IDA7XG4gICAgICBjb25zdCB0cmltQm90dG9tID0gYm9hcmQudHJpbV9ib3R0b21fbW0gPz8gMDtcbiAgICAgIGNvbnN0IGtlcmZTaXplID0gcGFyYW1zLmtlcmZfbW0gPz8gMztcblxuICAgICAgLy8gQ1JJVElDQUw6IFN3YXAgYm9hcmQgZGltZW5zaW9ucyB0byBwbGFjZSBwYW5lbHMgYWxvbmcgdGhlIExFTkdUSCBzaWRlIChsb25nZXIgZGltZW5zaW9uKVxuICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBQSFAgbG9naWMgZXhhY3RseVxuICAgICAgY29uc3QgYm9hcmRXaWR0aFN3YXBwZWQgPSBib2FyZEhlaWdodDsgIC8vIDIwNzAgKG5vdyB0cmVhdGVkIGFzIHdpZHRoIGZvciBob3Jpem9udGFsIHBsYWNlbWVudClcbiAgICAgIGNvbnN0IGJvYXJkSGVpZ2h0U3dhcHBlZCA9IGJvYXJkV2lkdGg7ICAvLyAyODAwIChub3cgdHJlYXRlZCBhcyBoZWlnaHQgZm9yIHZlcnRpY2FsIHN0YWNraW5nKVxuXG4gICAgICAvLyBDYWxjdWxhdGUgdXNhYmxlIGJvYXJkIGRpbWVuc2lvbnMgYWZ0ZXIgdHJpbVxuICAgICAgY29uc3QgeyB1c2FibGVXaWR0aCwgdXNhYmxlSGVpZ2h0IH0gPSBjYWxjdWxhdGVVc2FibGVCb2FyZERpbWVuc2lvbnMoXG4gICAgICAgIGJvYXJkV2lkdGhTd2FwcGVkLFxuICAgICAgICBib2FyZEhlaWdodFN3YXBwZWQsXG4gICAgICAgIHRyaW1MZWZ0LFxuICAgICAgICB0cmltUmlnaHQsXG4gICAgICAgIHRyaW1Ub3AsXG4gICAgICAgIHRyaW1Cb3R0b21cbiAgICAgICk7XG5cbiAgICAgIC8vIFVzZSB0aGUgZ3VpbGxvdGluZSBjdXR0aW5nIGFsZ29yaXRobVxuICAgICAgY29uc29sZS50aW1lKGBbQVBJXSBHdWlsbG90aW5lIEFsZ29yaXRobTogJHttYXRlcmlhbE5hbWV9YClcbiAgICAgIGNvbnN0IGJpbnMgPSBndWlsbG90aW5lQ3V0dGluZyhwYW5lbHMsIHVzYWJsZVdpZHRoLCB1c2FibGVIZWlnaHQsIGtlcmZTaXplKTtcbiAgICAgIGNvbnNvbGUudGltZUVuZChgW0FQSV0gR3VpbGxvdGluZSBBbGdvcml0aG06ICR7bWF0ZXJpYWxOYW1lfWApXG4gICAgICBjb25zb2xlLmxvZyhgW0FQSV0gJHttYXRlcmlhbE5hbWV9OiBDcmVhdGVkICR7Ymlucy5sZW5ndGh9IGJpbnMgZm9yICR7cGFuZWxzLmxlbmd0aH0gcGFuZWxzYClcblxuICAgICAgLy8gQ29udmVydCB0byByZXNwb25zZSBmb3JtYXQgLSBwcm9jZXNzIEFMTCBib2FyZHNcbiAgICAgIGNvbnN0IHBsYWNlbWVudHM6IFBsYWNlbWVudFtdID0gW107XG4gICAgICBjb25zdCB1bnBsYWNlZDogVW5wbGFjZWRQYXJ0W10gPSBbXTtcbiAgICAgIGNvbnN0IHBsYWNlZFBhbmVsSWRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgY29uc3QgYm9hcmRDdXRMZW5ndGhzOiBSZWNvcmQ8bnVtYmVyLCBudW1iZXI+ID0ge307XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIGJpbnMgKGFsbCBib2FyZHMpXG4gICAgICBjb25zb2xlLnRpbWUoYFtBUEldIFByb2Nlc3MgQmluczogJHttYXRlcmlhbE5hbWV9YClcbiAgICAgIGlmIChiaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgYmluSW5kZXggPSAwOyBiaW5JbmRleCA8IGJpbnMubGVuZ3RoOyBiaW5JbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgYmluID0gYmluc1tiaW5JbmRleF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIGFjdHVhbCBjdXQgbGVuZ3RoIHVzaW5nIHRoZSBzb3BoaXN0aWNhdGVkIGFsZ29yaXRobVxuICAgICAgICAgIGNvbnN0IGJvYXJkQ3V0TGVuZ3RoID0gcHJvY2Vzc0JpbihiaW4sIHRyaW1MZWZ0LCB0cmltUmlnaHQsIHRyaW1Ub3AsIHRyaW1Cb3R0b20pO1xuICAgICAgICAgIGJvYXJkQ3V0TGVuZ3Roc1tiaW5JbmRleCArIDFdID0gYm9hcmRDdXRMZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHJlY3Qgb2YgYmluLnVzZWRSZWN0YW5nbGVzKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBvcmlnaW5hbCBwYW5lbCBkYXRhIHRoYXQgbWF0Y2hlcyB0aGlzIHJlY3RhbmdsZVxuICAgICAgICAgICAgbGV0IG9yaWdpbmFsUGFuZWw6IGFueSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxJbmRleCA9IC0xO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHdoaWNoIHBhcnQgdGhpcyBwYW5lbCBjYW1lIGZyb20gYnkgY2hlY2tpbmcgZGltZW5zaW9uc1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgIGNvbnN0IHF1YW50aXR5ID0gcGFydC5xdHkgPz8gMTtcblxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkaW1lbnNpb25zIG1hdGNoIChhY2NvdW50aW5nIGZvciBwb3NzaWJsZSByb3RhdGlvbilcbiAgICAgICAgICAgICAgLy8gTm90ZTogd19tbSA9IGhvc3N6w7pzw6FnLCBoX21tID0gc3rDqWxlc3PDqWcgaW4gdGhlIEFQSSByZXF1ZXN0XG4gICAgICAgICAgICAgIC8vIFJlY3RhbmdsZSBjb25zdHJ1Y3RvcjogbmV3IFJlY3RhbmdsZSgkcGFydFsnaF9tbSddLCAkcGFydFsnd19tbSddLCAuLi4pXG4gICAgICAgICAgICAgIC8vIFNvIHJlY3QtPndpZHRoID0gaF9tbSAoc3rDqWxlc3PDqWcpLCByZWN0LT5oZWlnaHQgPSB3X21tIChob3NzesO6c8OhZylcbiAgICAgICAgICAgICAgaWYgKChwYXJ0LmhfbW0gPT09IHJlY3Qud2lkdGggJiYgcGFydC53X21tID09PSByZWN0LmhlaWdodCkgfHxcbiAgICAgICAgICAgICAgICAgIChwYXJ0LmhfbW0gPT09IHJlY3QuaGVpZ2h0ICYmIHBhcnQud19tbSA9PT0gcmVjdC53aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDb3VudCBob3cgbWFueSBvZiB0aGlzIHBhcnQgdHlwZSB3ZSd2ZSBhbHJlYWR5IHBsYWNlZFxuICAgICAgICAgICAgICAgIGxldCBhbHJlYWR5UGxhY2VkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGxhY2VkSWQgb2YgcGxhY2VkUGFuZWxJZHMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwbGFjZWRJZC5zdGFydHNXaXRoKHBhcnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlQbGFjZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgcGxhY2VkIGFsbCBxdWFudGl0aWVzIG9mIHRoaXMgcGFydCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeVBsYWNlZENvdW50IDwgcXVhbnRpdHkpIHtcbiAgICAgICAgICAgICAgICAgIG9yaWdpbmFsUGFuZWwgPSBwYXJ0O1xuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUGFuZWwpIHtcbiAgICAgICAgICAgICAgbGV0IGluc3RhbmNlTnVtYmVyID0gMTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwbGFjZWRJZCBvZiBwbGFjZWRQYW5lbElkcykge1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZWRJZC5zdGFydHNXaXRoKG9yaWdpbmFsUGFuZWwuaWQpKSB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZU51bWJlcisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGAke29yaWdpbmFsUGFuZWwuaWR9LSR7aW5zdGFuY2VOdW1iZXJ9YCxcbiAgICAgICAgICAgICAgICB4X21tOiByZWN0LnggKyB0cmltTGVmdCxcbiAgICAgICAgICAgICAgICB5X21tOiByZWN0LnkgKyB0cmltVG9wLFxuICAgICAgICAgICAgICAgIHdfbW06IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaF9tbTogcmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcm90X2RlZzogMCxcbiAgICAgICAgICAgICAgICBib2FyZF9pZDogYmluSW5kZXggKyAxXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwbGFjZWRQYW5lbElkcy5wdXNoKGAke29yaWdpbmFsUGFuZWwuaWR9LSR7aW5zdGFuY2VOdW1iZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zb2xlLnRpbWVFbmQoYFtBUEldIFByb2Nlc3MgQmluczogJHttYXRlcmlhbE5hbWV9YClcblxuICAgICAgLy8gTWFyayByZW1haW5pbmcgcGFuZWxzIGFzIHVucGxhY2VkXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgY29uc3QgcXVhbnRpdHkgPSBwYXJ0LnF0eSA/PyAxO1xuXG4gICAgICAgIC8vIENvdW50IGhvdyBtYW55IG9mIHRoaXMgcGFydCB0eXBlIHdlcmUgcGxhY2VkXG4gICAgICAgIGxldCBwbGFjZWRDb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGxhY2VkSWQgb2YgcGxhY2VkUGFuZWxJZHMpIHtcbiAgICAgICAgICBpZiAocGxhY2VkSWQuc3RhcnRzV2l0aChwYXJ0LmlkKSkge1xuICAgICAgICAgICAgcGxhY2VkQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdW5wbGFjZWQgaW5zdGFuY2VzXG4gICAgICAgIGZvciAobGV0IGogPSBwbGFjZWRDb3VudDsgaiA8IHF1YW50aXR5OyBqKyspIHtcbiAgICAgICAgICB1bnBsYWNlZC5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBgJHtwYXJ0LmlkfS0ke2ogKyAxfWAsXG4gICAgICAgICAgICB3X21tOiBwYXJ0LndfbW0sXG4gICAgICAgICAgICBoX21tOiBwYXJ0LmhfbW0sXG4gICAgICAgICAgICByZWFzb246ICdObyBzcGFjZSBhdmFpbGFibGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FsY3VsYXRlIG1ldHJpY3NcbiAgICAgIGxldCB0b3RhbFVzZWRBcmVhID0gMDtcbiAgICAgIGZvciAoY29uc3QgcGxhY2VtZW50IG9mIHBsYWNlbWVudHMpIHtcbiAgICAgICAgdG90YWxVc2VkQXJlYSArPSBwbGFjZW1lbnQud19tbSAqIHBsYWNlbWVudC5oX21tO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBib2FyZEFyZWEgPSBib2FyZFdpZHRoU3dhcHBlZCAqIGJvYXJkSGVpZ2h0U3dhcHBlZDtcbiAgICAgIGNvbnN0IHRvdGFsQm9hcmRBcmVhID0gYm9hcmRBcmVhICogYmlucy5sZW5ndGg7XG4gICAgICBjb25zdCB3YXN0ZVBlcmNlbnRhZ2UgPSB0b3RhbEJvYXJkQXJlYSA+IDAgPyAoKHRvdGFsQm9hcmRBcmVhIC0gdG90YWxVc2VkQXJlYSkgLyB0b3RhbEJvYXJkQXJlYSkgKiAxMDAgOiAwO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdG90YWwgY3V0IGxlbmd0aFxuICAgICAgY29uc3QgdG90YWxDdXRMZW5ndGggPSBPYmplY3QudmFsdWVzKGJvYXJkQ3V0TGVuZ3RocykucmVkdWNlKChzdW0sIGxlbmd0aCkgPT4gc3VtICsgbGVuZ3RoLCAwKTtcblxuICAgICAgLy8gQWRkIHJlc3VsdCBmb3IgdGhpcyBtYXRlcmlhbFxuICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgbWF0ZXJpYWxfaWQ6IG1hdGVyaWFsSWQsXG4gICAgICAgIG1hdGVyaWFsX25hbWU6IG1hdGVyaWFsTmFtZSxcbiAgICAgICAgcGxhY2VtZW50czogcGxhY2VtZW50cyxcbiAgICAgICAgdW5wbGFjZWQ6IHVucGxhY2VkLFxuICAgICAgICBtZXRyaWNzOiB7XG4gICAgICAgICAgdXNlZF9hcmVhX21tMjogdG90YWxVc2VkQXJlYSxcbiAgICAgICAgICBib2FyZF9hcmVhX21tMjogdG90YWxCb2FyZEFyZWEsXG4gICAgICAgICAgd2FzdGVfcGN0OiBNYXRoLnJvdW5kKHdhc3RlUGVyY2VudGFnZSAqIDEwMCkgLyAxMDAsIC8vIFJvdW5kIHRvIDIgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICBwbGFjZWRfY291bnQ6IHBsYWNlbWVudHMubGVuZ3RoLFxuICAgICAgICAgIHVucGxhY2VkX2NvdW50OiB1bnBsYWNlZC5sZW5ndGgsXG4gICAgICAgICAgYm9hcmRzX3VzZWQ6IGJpbnMubGVuZ3RoLFxuICAgICAgICAgIHRvdGFsX2N1dF9sZW5ndGhfbW06IHRvdGFsQ3V0TGVuZ3RoXG4gICAgICAgIH0sXG4gICAgICAgIGJvYXJkX2N1dF9sZW5ndGhzOiBib2FyZEN1dExlbmd0aHMsXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgYm9hcmRfd2lkdGg6IGJvYXJkV2lkdGhTd2FwcGVkLFxuICAgICAgICAgIGJvYXJkX2hlaWdodDogYm9hcmRIZWlnaHRTd2FwcGVkLFxuICAgICAgICAgIHVzYWJsZV93aWR0aDogdXNhYmxlV2lkdGgsXG4gICAgICAgICAgdXNhYmxlX2hlaWdodDogdXNhYmxlSGVpZ2h0LFxuICAgICAgICAgIGJpbnNfY291bnQ6IGJpbnMubGVuZ3RoLFxuICAgICAgICAgIHBhbmVsc19jb3VudDogcGFuZWxzLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbWF0ZXJpYWxEdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbWF0ZXJpYWxTdGFydFRpbWVcbiAgICAgIGNvbnNvbGUubG9nKGBbQVBJXSDinIUgJHttYXRlcmlhbE5hbWV9IGNvbXBsZXRlIGluICR7bWF0ZXJpYWxEdXJhdGlvbi50b0ZpeGVkKDIpfW1zICgke2JpbnMubGVuZ3RofSBib2FyZHMsICR7cGxhY2VtZW50cy5sZW5ndGh9IHBsYWNlbWVudHMpYClcbiAgICB9XG5cbiAgICBjb25zb2xlLnRpbWVFbmQoJ1tBUEldIFRvdGFsIE9wdGltaXphdGlvbiBUaW1lJylcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBhcGlTdGFydFRpbWVcbiAgICBjb25zb2xlLmxvZyhgW0FQSV0g4pyFIEFsbCBtYXRlcmlhbHMgb3B0aW1pemVkIGluICR7dG90YWxEdXJhdGlvbi50b0ZpeGVkKDIpfW1zYClcblxuICAgIC8vIFJldHVybiByZXN1bHRzIGFycmF5IGRpcmVjdGx5IGFzIGV4cGVjdGVkIGJ5IE9wdGlDbGllbnRcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzdWx0cywgeyBoZWFkZXJzOiBjb3JzSGVhZGVycyB9KTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ09wdGltaXphdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBzdGF0dXM6ICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdPcHRpbWl6YXRpb24gc2VydmljZSBlcnJvcicsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICB7IHN0YXR1czogNTAwLCBoZWFkZXJzOiBjb3JzSGVhZGVycyB9XG4gICAgKTtcbiAgfVxufSJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJndWlsbG90aW5lQ3V0dGluZyIsInByb2Nlc3NQYW5lbHNGb3JNYXRlcmlhbCIsImNhbGN1bGF0ZVVzYWJsZUJvYXJkRGltZW5zaW9ucyIsInByb2Nlc3NCaW4iLCJjb3JzSGVhZGVycyIsIk9QVElPTlMiLCJzdGF0dXMiLCJoZWFkZXJzIiwiUE9TVCIsInJlcXVlc3QiLCJhcGlTdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImlucHV0IiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsIm1hdGVyaWFscyIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsInRpbWUiLCJyZXN1bHRzIiwibWF0ZXJpYWxEYXRhIiwibWF0ZXJpYWxTdGFydFRpbWUiLCJtYXRlcmlhbElkIiwiaWQiLCJtYXRlcmlhbE5hbWUiLCJuYW1lIiwicGFydHMiLCJib2FyZCIsInBhcmFtcyIsInBhbmVscyIsInRpbWVFbmQiLCJib2FyZFdpZHRoIiwid19tbSIsImJvYXJkSGVpZ2h0IiwiaF9tbSIsInRyaW1MZWZ0IiwidHJpbV9sZWZ0X21tIiwidHJpbVJpZ2h0IiwidHJpbV9yaWdodF9tbSIsInRyaW1Ub3AiLCJ0cmltX3RvcF9tbSIsInRyaW1Cb3R0b20iLCJ0cmltX2JvdHRvbV9tbSIsImtlcmZTaXplIiwia2VyZl9tbSIsImJvYXJkV2lkdGhTd2FwcGVkIiwiYm9hcmRIZWlnaHRTd2FwcGVkIiwidXNhYmxlV2lkdGgiLCJ1c2FibGVIZWlnaHQiLCJiaW5zIiwicGxhY2VtZW50cyIsInVucGxhY2VkIiwicGxhY2VkUGFuZWxJZHMiLCJib2FyZEN1dExlbmd0aHMiLCJiaW5JbmRleCIsImJpbiIsImJvYXJkQ3V0TGVuZ3RoIiwicmVjdCIsInVzZWRSZWN0YW5nbGVzIiwib3JpZ2luYWxQYW5lbCIsIm9yaWdpbmFsSW5kZXgiLCJpIiwicGFydCIsInF1YW50aXR5IiwicXR5Iiwid2lkdGgiLCJoZWlnaHQiLCJhbHJlYWR5UGxhY2VkQ291bnQiLCJwbGFjZWRJZCIsInN0YXJ0c1dpdGgiLCJpbnN0YW5jZU51bWJlciIsInB1c2giLCJ4X21tIiwieCIsInlfbW0iLCJ5Iiwicm90X2RlZyIsImJvYXJkX2lkIiwicGxhY2VkQ291bnQiLCJqIiwicmVhc29uIiwidG90YWxVc2VkQXJlYSIsInBsYWNlbWVudCIsImJvYXJkQXJlYSIsInRvdGFsQm9hcmRBcmVhIiwid2FzdGVQZXJjZW50YWdlIiwidG90YWxDdXRMZW5ndGgiLCJPYmplY3QiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJzdW0iLCJtYXRlcmlhbF9pZCIsIm1hdGVyaWFsX25hbWUiLCJtZXRyaWNzIiwidXNlZF9hcmVhX21tMiIsImJvYXJkX2FyZWFfbW0yIiwid2FzdGVfcGN0IiwiTWF0aCIsInJvdW5kIiwicGxhY2VkX2NvdW50IiwidW5wbGFjZWRfY291bnQiLCJib2FyZHNfdXNlZCIsInRvdGFsX2N1dF9sZW5ndGhfbW0iLCJib2FyZF9jdXRfbGVuZ3RocyIsImRlYnVnIiwiYm9hcmRfd2lkdGgiLCJib2FyZF9oZWlnaHQiLCJ1c2FibGVfd2lkdGgiLCJ1c2FibGVfaGVpZ2h0IiwiYmluc19jb3VudCIsInBhbmVsc19jb3VudCIsIm1hdGVyaWFsRHVyYXRpb24iLCJ0b0ZpeGVkIiwidG90YWxEdXJhdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/optimize/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/optimization/algorithms.ts":
/*!********************************************!*\
  !*** ./src/lib/optimization/algorithms.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateBoardsNeeded: () => (/* binding */ calculateBoardsNeeded),\n/* harmony export */   calculateUsableBoardDimensions: () => (/* binding */ calculateUsableBoardDimensions),\n/* harmony export */   guillotineCutting: () => (/* binding */ guillotineCutting),\n/* harmony export */   processPanelsForMaterial: () => (/* binding */ processPanelsForMaterial),\n/* harmony export */   sortRectanglesByX: () => (/* binding */ sortRectanglesByX),\n/* harmony export */   sortRectanglesByY: () => (/* binding */ sortRectanglesByY)\n/* harmony export */ });\n/* harmony import */ var _classes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes */ \"(rsc)/./src/lib/optimization/classes.ts\");\n// Core Optimization Algorithms - TypeScript version of PHP functions\n\n/**\n * Guillotine cutting algorithm - main optimization function\n * Mirrors the PHP guillotineCutting function exactly\n */ function guillotineCutting(rectangles, binWidth, binHeight, kerf = 0) {\n    const bins = [];\n    bins.push(new _classes__WEBPACK_IMPORTED_MODULE_0__.BinClass(binWidth, binHeight, kerf));\n    // Sort rectangles by area (largest first) - exactly like PHP\n    rectangles.sort((a, b)=>b.width * b.height - a.width * a.height);\n    for (const rectangle of rectangles){\n        let placed = false;\n        for (const bin of bins){\n            if (bin.insert(rectangle, kerf)) {\n                placed = true;\n                break;\n            }\n        }\n        if (!placed) {\n            const newBin = new _classes__WEBPACK_IMPORTED_MODULE_0__.BinClass(binWidth, binHeight, kerf);\n            newBin.insert(rectangle, kerf);\n            bins.push(newBin);\n        }\n    }\n    return bins;\n}\n/**\n * Calculate number of boards needed - utility function\n */ function calculateBoardsNeeded(rectangles, binWidth, binHeight) {\n    const bins = guillotineCutting(rectangles, binWidth, binHeight);\n    return bins.length;\n}\n/**\n * Process panels for a material - convert parts to rectangles\n * Mirrors the PHP logic for processing parts and handling quantities\n */ function processPanelsForMaterial(parts, grainDirection = false) {\n    const panels = [];\n    for (const part of parts){\n        const quantity = part.qty ?? 1;\n        for(let i = 0; i < quantity; i++){\n            // Check if material has grain direction - if so, panels cannot be rotated\n            const canRotate = grainDirection ? false : part.allow_rot_90 ?? true;\n            panels.push(new _classes__WEBPACK_IMPORTED_MODULE_0__.RectangleClass(part.h_mm, part.w_mm, 0, 0, canRotate));\n        }\n    }\n    return panels;\n}\n/**\n * Calculate board dimensions with trim\n */ function calculateUsableBoardDimensions(boardWidth, boardHeight, trimLeft = 0, trimRight = 0, trimTop = 0, trimBottom = 0) {\n    const usableWidth = boardWidth - trimLeft - trimRight;\n    const usableHeight = boardHeight - trimTop - trimBottom;\n    return {\n        usableWidth,\n        usableHeight\n    };\n}\n/**\n * Sort rectangles by Y position for strip processing\n */ function sortRectanglesByY(rectangles) {\n    return rectangles.sort((a, b)=>a.y - b.y);\n}\n/**\n * Sort rectangles by X position for strip processing\n */ function sortRectanglesByX(rectangles) {\n    return rectangles.sort((a, b)=>a.x - b.x);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL29wdGltaXphdGlvbi9hbGdvcml0aG1zLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxxRUFBcUU7QUFDaEI7QUFHckQ7OztDQUdDLEdBQ00sU0FBU0Usa0JBQ2RDLFVBQTRCLEVBQzVCQyxRQUFnQixFQUNoQkMsU0FBaUIsRUFDakJDLE9BQWUsQ0FBQztJQUVoQixNQUFNQyxPQUFtQixFQUFFO0lBQzNCQSxLQUFLQyxJQUFJLENBQUMsSUFBSVAsOENBQVFBLENBQUNHLFVBQVVDLFdBQVdDO0lBRTVDLDZEQUE2RDtJQUM3REgsV0FBV00sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU0sRUFBR0MsS0FBSyxHQUFHRCxFQUFFRSxNQUFNLEdBQUtILEVBQUVFLEtBQUssR0FBR0YsRUFBRUcsTUFBTTtJQUVwRSxLQUFLLE1BQU1DLGFBQWFYLFdBQVk7UUFDbEMsSUFBSVksU0FBUztRQUNiLEtBQUssTUFBTUMsT0FBT1QsS0FBTTtZQUN0QixJQUFJUyxJQUFJQyxNQUFNLENBQUNILFdBQVdSLE9BQU87Z0JBQy9CUyxTQUFTO2dCQUNUO1lBQ0Y7UUFDRjtRQUNBLElBQUksQ0FBQ0EsUUFBUTtZQUNYLE1BQU1HLFNBQVMsSUFBSWpCLDhDQUFRQSxDQUFDRyxVQUFVQyxXQUFXQztZQUNqRFksT0FBT0QsTUFBTSxDQUFDSCxXQUFXUjtZQUN6QkMsS0FBS0MsSUFBSSxDQUFDVTtRQUNaO0lBQ0Y7SUFFQSxPQUFPWDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTWSxzQkFDZGhCLFVBQTRCLEVBQzVCQyxRQUFnQixFQUNoQkMsU0FBaUI7SUFFakIsTUFBTUUsT0FBT0wsa0JBQWtCQyxZQUFZQyxVQUFVQztJQUNyRCxPQUFPRSxLQUFLYSxNQUFNO0FBQ3BCO0FBRUE7OztDQUdDLEdBQ00sU0FBU0MseUJBQ2RDLEtBQVksRUFDWkMsaUJBQTBCLEtBQUs7SUFFL0IsTUFBTUMsU0FBMkIsRUFBRTtJQUVuQyxLQUFLLE1BQU1DLFFBQVFILE1BQU87UUFDeEIsTUFBTUksV0FBV0QsS0FBS0UsR0FBRyxJQUFJO1FBQzdCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixVQUFVRSxJQUFLO1lBQ2pDLDBFQUEwRTtZQUMxRSxNQUFNQyxZQUFZTixpQkFBaUIsUUFBU0UsS0FBS0ssWUFBWSxJQUFJO1lBQ2pFTixPQUFPaEIsSUFBSSxDQUFDLElBQUlSLG9EQUFjQSxDQUM1QnlCLEtBQUtNLElBQUksRUFDVE4sS0FBS08sSUFBSSxFQUNULEdBQ0EsR0FDQUg7UUFFSjtJQUNGO0lBRUEsT0FBT0w7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU1MsK0JBQ2RDLFVBQWtCLEVBQ2xCQyxXQUFtQixFQUNuQkMsV0FBbUIsQ0FBQyxFQUNwQkMsWUFBb0IsQ0FBQyxFQUNyQkMsVUFBa0IsQ0FBQyxFQUNuQkMsYUFBcUIsQ0FBQztJQUV0QixNQUFNQyxjQUFjTixhQUFhRSxXQUFXQztJQUM1QyxNQUFNSSxlQUFlTixjQUFjRyxVQUFVQztJQUU3QyxPQUFPO1FBQUVDO1FBQWFDO0lBQWE7QUFDckM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLGtCQUFrQnZDLFVBQXVCO0lBQ3ZELE9BQU9BLFdBQVdNLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFaUMsQ0FBQyxHQUFHaEMsRUFBRWdDLENBQUM7QUFDNUM7QUFFQTs7Q0FFQyxHQUNNLFNBQVNDLGtCQUFrQnpDLFVBQXVCO0lBQ3ZELE9BQU9BLFdBQVdNLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFbUMsQ0FBQyxHQUFHbEMsRUFBRWtDLENBQUM7QUFDNUMiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1Q3L2VycF90dXJpbm92YV9uZXcvc3JjL2xpYi9vcHRpbWl6YXRpb24vYWxnb3JpdGhtcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3JlIE9wdGltaXphdGlvbiBBbGdvcml0aG1zIC0gVHlwZVNjcmlwdCB2ZXJzaW9uIG9mIFBIUCBmdW5jdGlvbnNcbmltcG9ydCB7IFJlY3RhbmdsZUNsYXNzLCBCaW5DbGFzcyB9IGZyb20gJy4vY2xhc3Nlcyc7XG5pbXBvcnQgdHlwZSB7IFJlY3RhbmdsZSB9IGZyb20gJ0AvdHlwZXMvb3B0aW1pemF0aW9uJztcblxuLyoqXG4gKiBHdWlsbG90aW5lIGN1dHRpbmcgYWxnb3JpdGhtIC0gbWFpbiBvcHRpbWl6YXRpb24gZnVuY3Rpb25cbiAqIE1pcnJvcnMgdGhlIFBIUCBndWlsbG90aW5lQ3V0dGluZyBmdW5jdGlvbiBleGFjdGx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBndWlsbG90aW5lQ3V0dGluZyhcbiAgcmVjdGFuZ2xlczogUmVjdGFuZ2xlQ2xhc3NbXSwgXG4gIGJpbldpZHRoOiBudW1iZXIsIFxuICBiaW5IZWlnaHQ6IG51bWJlciwgXG4gIGtlcmY6IG51bWJlciA9IDBcbik6IEJpbkNsYXNzW10ge1xuICBjb25zdCBiaW5zOiBCaW5DbGFzc1tdID0gW107XG4gIGJpbnMucHVzaChuZXcgQmluQ2xhc3MoYmluV2lkdGgsIGJpbkhlaWdodCwga2VyZikpO1xuXG4gIC8vIFNvcnQgcmVjdGFuZ2xlcyBieSBhcmVhIChsYXJnZXN0IGZpcnN0KSAtIGV4YWN0bHkgbGlrZSBQSFBcbiAgcmVjdGFuZ2xlcy5zb3J0KChhLCBiKSA9PiAoYi53aWR0aCAqIGIuaGVpZ2h0KSAtIChhLndpZHRoICogYS5oZWlnaHQpKTtcblxuICBmb3IgKGNvbnN0IHJlY3RhbmdsZSBvZiByZWN0YW5nbGVzKSB7XG4gICAgbGV0IHBsYWNlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgYmluIG9mIGJpbnMpIHtcbiAgICAgIGlmIChiaW4uaW5zZXJ0KHJlY3RhbmdsZSwga2VyZikpIHtcbiAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcGxhY2VkKSB7XG4gICAgICBjb25zdCBuZXdCaW4gPSBuZXcgQmluQ2xhc3MoYmluV2lkdGgsIGJpbkhlaWdodCwga2VyZik7XG4gICAgICBuZXdCaW4uaW5zZXJ0KHJlY3RhbmdsZSwga2VyZik7XG4gICAgICBiaW5zLnB1c2gobmV3QmluKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmlucztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgbnVtYmVyIG9mIGJvYXJkcyBuZWVkZWQgLSB1dGlsaXR5IGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVCb2FyZHNOZWVkZWQoXG4gIHJlY3RhbmdsZXM6IFJlY3RhbmdsZUNsYXNzW10sIFxuICBiaW5XaWR0aDogbnVtYmVyLCBcbiAgYmluSGVpZ2h0OiBudW1iZXJcbik6IG51bWJlciB7XG4gIGNvbnN0IGJpbnMgPSBndWlsbG90aW5lQ3V0dGluZyhyZWN0YW5nbGVzLCBiaW5XaWR0aCwgYmluSGVpZ2h0KTtcbiAgcmV0dXJuIGJpbnMubGVuZ3RoO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgcGFuZWxzIGZvciBhIG1hdGVyaWFsIC0gY29udmVydCBwYXJ0cyB0byByZWN0YW5nbGVzXG4gKiBNaXJyb3JzIHRoZSBQSFAgbG9naWMgZm9yIHByb2Nlc3NpbmcgcGFydHMgYW5kIGhhbmRsaW5nIHF1YW50aXRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NQYW5lbHNGb3JNYXRlcmlhbChcbiAgcGFydHM6IGFueVtdLCBcbiAgZ3JhaW5EaXJlY3Rpb246IGJvb2xlYW4gPSBmYWxzZVxuKTogUmVjdGFuZ2xlQ2xhc3NbXSB7XG4gIGNvbnN0IHBhbmVsczogUmVjdGFuZ2xlQ2xhc3NbXSA9IFtdO1xuICBcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgY29uc3QgcXVhbnRpdHkgPSBwYXJ0LnF0eSA/PyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhbnRpdHk7IGkrKykge1xuICAgICAgLy8gQ2hlY2sgaWYgbWF0ZXJpYWwgaGFzIGdyYWluIGRpcmVjdGlvbiAtIGlmIHNvLCBwYW5lbHMgY2Fubm90IGJlIHJvdGF0ZWRcbiAgICAgIGNvbnN0IGNhblJvdGF0ZSA9IGdyYWluRGlyZWN0aW9uID8gZmFsc2UgOiAocGFydC5hbGxvd19yb3RfOTAgPz8gdHJ1ZSk7XG4gICAgICBwYW5lbHMucHVzaChuZXcgUmVjdGFuZ2xlQ2xhc3MoXG4gICAgICAgIHBhcnQuaF9tbSwgIC8vIE5vdGU6IFBIUCB1c2VzIGhfbW0gYXMgd2lkdGggaW4gUmVjdGFuZ2xlIGNvbnN0cnVjdG9yXG4gICAgICAgIHBhcnQud19tbSwgIC8vIE5vdGU6IFBIUCB1c2VzIHdfbW0gYXMgaGVpZ2h0IGluIFJlY3RhbmdsZSBjb25zdHJ1Y3RvclxuICAgICAgICAwLCBcbiAgICAgICAgMCwgXG4gICAgICAgIGNhblJvdGF0ZVxuICAgICAgKSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gcGFuZWxzO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBib2FyZCBkaW1lbnNpb25zIHdpdGggdHJpbVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVXNhYmxlQm9hcmREaW1lbnNpb25zKFxuICBib2FyZFdpZHRoOiBudW1iZXIsXG4gIGJvYXJkSGVpZ2h0OiBudW1iZXIsXG4gIHRyaW1MZWZ0OiBudW1iZXIgPSAwLFxuICB0cmltUmlnaHQ6IG51bWJlciA9IDAsXG4gIHRyaW1Ub3A6IG51bWJlciA9IDAsXG4gIHRyaW1Cb3R0b206IG51bWJlciA9IDBcbik6IHsgdXNhYmxlV2lkdGg6IG51bWJlcjsgdXNhYmxlSGVpZ2h0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHVzYWJsZVdpZHRoID0gYm9hcmRXaWR0aCAtIHRyaW1MZWZ0IC0gdHJpbVJpZ2h0O1xuICBjb25zdCB1c2FibGVIZWlnaHQgPSBib2FyZEhlaWdodCAtIHRyaW1Ub3AgLSB0cmltQm90dG9tO1xuICBcbiAgcmV0dXJuIHsgdXNhYmxlV2lkdGgsIHVzYWJsZUhlaWdodCB9O1xufVxuXG4vKipcbiAqIFNvcnQgcmVjdGFuZ2xlcyBieSBZIHBvc2l0aW9uIGZvciBzdHJpcCBwcm9jZXNzaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0UmVjdGFuZ2xlc0J5WShyZWN0YW5nbGVzOiBSZWN0YW5nbGVbXSk6IFJlY3RhbmdsZVtdIHtcbiAgcmV0dXJuIHJlY3RhbmdsZXMuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbn1cblxuLyoqXG4gKiBTb3J0IHJlY3RhbmdsZXMgYnkgWCBwb3NpdGlvbiBmb3Igc3RyaXAgcHJvY2Vzc2luZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydFJlY3RhbmdsZXNCeVgocmVjdGFuZ2xlczogUmVjdGFuZ2xlW10pOiBSZWN0YW5nbGVbXSB7XG4gIHJldHVybiByZWN0YW5nbGVzLnNvcnQoKGEsIGIpID0+IGEueCAtIGIueCk7XG59XG4iXSwibmFtZXMiOlsiUmVjdGFuZ2xlQ2xhc3MiLCJCaW5DbGFzcyIsImd1aWxsb3RpbmVDdXR0aW5nIiwicmVjdGFuZ2xlcyIsImJpbldpZHRoIiwiYmluSGVpZ2h0Iiwia2VyZiIsImJpbnMiLCJwdXNoIiwic29ydCIsImEiLCJiIiwid2lkdGgiLCJoZWlnaHQiLCJyZWN0YW5nbGUiLCJwbGFjZWQiLCJiaW4iLCJpbnNlcnQiLCJuZXdCaW4iLCJjYWxjdWxhdGVCb2FyZHNOZWVkZWQiLCJsZW5ndGgiLCJwcm9jZXNzUGFuZWxzRm9yTWF0ZXJpYWwiLCJwYXJ0cyIsImdyYWluRGlyZWN0aW9uIiwicGFuZWxzIiwicGFydCIsInF1YW50aXR5IiwicXR5IiwiaSIsImNhblJvdGF0ZSIsImFsbG93X3JvdF85MCIsImhfbW0iLCJ3X21tIiwiY2FsY3VsYXRlVXNhYmxlQm9hcmREaW1lbnNpb25zIiwiYm9hcmRXaWR0aCIsImJvYXJkSGVpZ2h0IiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJ0cmltVG9wIiwidHJpbUJvdHRvbSIsInVzYWJsZVdpZHRoIiwidXNhYmxlSGVpZ2h0Iiwic29ydFJlY3RhbmdsZXNCeVkiLCJ5Iiwic29ydFJlY3RhbmdsZXNCeVgiLCJ4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/optimization/algorithms.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/optimization/classes.ts":
/*!*****************************************!*\
  !*** ./src/lib/optimization/classes.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinClass: () => (/* binding */ BinClass),\n/* harmony export */   RectangleClass: () => (/* binding */ RectangleClass)\n/* harmony export */ });\n// Optimization Classes - TypeScript version of PHP classes\nclass RectangleClass {\n    constructor(width, height, x = 0, y = 0, rotatable = false){\n        this.width = width;\n        this.height = height;\n        this.x = x;\n        this.y = y;\n        this.rotatable = rotatable;\n    }\n}\nclass BinClass {\n    constructor(width, height, kerf = 0){\n        this.usedRectangles = [];\n        this.freeRectangles = [];\n        this.width = width;\n        this.height = height;\n        this.kerf = kerf;\n        this.freeRectangles.push(new RectangleClass(width, height));\n    }\n    insert(rectangle, kerf = 0) {\n        let bestFit = null;\n        let bestFitIndex = -1;\n        let bestWaste = Number.MAX_SAFE_INTEGER;\n        let rotated = false;\n        for(let index = 0; index < this.freeRectangles.length; index++){\n            const freeRect = this.freeRectangles[index];\n            const normalWaste = (freeRect.width - rectangle.width) * (freeRect.height - rectangle.height);\n            const rotatedWaste = (freeRect.width - rectangle.height) * (freeRect.height - rectangle.width);\n            // Prioritize horizontal placement (leftmost, topmost)\n            // Only require kerf if there's remaining space that would need a cut\n            const requiresHorizontalKerf = freeRect.width > rectangle.width;\n            const requiresVerticalKerf = freeRect.height > rectangle.height;\n            if (freeRect.width >= rectangle.width + (requiresHorizontalKerf ? kerf : 0) && freeRect.height >= rectangle.height + (requiresVerticalKerf ? kerf : 0)) {\n                // Prefer horizontal placement by prioritizing lower y-coordinate, then lower x-coordinate\n                const wasteScore = normalWaste + freeRect.y * 10000 + freeRect.x * 1000;\n                if (wasteScore < bestWaste) {\n                    bestFit = freeRect;\n                    bestFitIndex = index;\n                    bestWaste = wasteScore;\n                    rotated = false;\n                }\n            }\n            if (rectangle.rotatable) {\n                const requiresHorizontalKerfRotated = freeRect.width > rectangle.height;\n                const requiresVerticalKerfRotated = freeRect.height > rectangle.width;\n                if (freeRect.width >= rectangle.height + (requiresHorizontalKerfRotated ? kerf : 0) && freeRect.height >= rectangle.width + (requiresVerticalKerfRotated ? kerf : 0)) {\n                    const wasteScore = rotatedWaste + freeRect.y * 10000 + freeRect.x * 1000;\n                    if (wasteScore < bestWaste) {\n                        bestFit = freeRect;\n                        bestFitIndex = index;\n                        bestWaste = wasteScore;\n                        rotated = true;\n                    }\n                }\n            }\n        }\n        if (bestFit === null) {\n            return false;\n        }\n        this.freeRectangles.splice(bestFitIndex, 1);\n        if (rotated) {\n            [rectangle.width, rectangle.height] = [\n                rectangle.height,\n                rectangle.width\n            ];\n        }\n        this.splitFreeSpaceHorizontalFirst(bestFit, rectangle, kerf);\n        rectangle.x = bestFit.x;\n        rectangle.y = bestFit.y;\n        this.usedRectangles.push(rectangle);\n        return true;\n    }\n    splitFreeSpaceHorizontalFirst(freeRect, placedRect, kerf = 0) {\n        const widthRemainder = freeRect.width - placedRect.width;\n        const heightRemainder = freeRect.height - placedRect.height;\n        // Prioritize horizontal cuts first (place panels side by side)\n        // Only apply kerf if there's actually space for another panel\n        if (widthRemainder > kerf) {\n            this.freeRectangles.push(new RectangleClass(widthRemainder - kerf, placedRect.height, freeRect.x + placedRect.width + kerf, freeRect.y));\n        }\n        if (heightRemainder > kerf) {\n            this.freeRectangles.push(new RectangleClass(freeRect.width, heightRemainder - kerf, freeRect.x, freeRect.y + placedRect.height + kerf));\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL29wdGltaXphdGlvbi9jbGFzc2VzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkRBQTJEO0FBR3BELE1BQU1BO0lBT1hDLFlBQ0VDLEtBQWEsRUFDYkMsTUFBYyxFQUNkQyxJQUFZLENBQUMsRUFDYkMsSUFBWSxDQUFDLEVBQ2JDLFlBQXFCLEtBQUssQ0FDMUI7UUFDQSxJQUFJLENBQUNKLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNDLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDbkI7QUFDRjtBQUVPLE1BQU1DO0lBT1hOLFlBQVlDLEtBQWEsRUFBRUMsTUFBYyxFQUFFSyxPQUFlLENBQUMsQ0FBRTthQUp0REMsaUJBQW1DLEVBQUU7YUFDckNDLGlCQUFtQyxFQUFFO1FBSTFDLElBQUksQ0FBQ1IsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0ssSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0UsY0FBYyxDQUFDQyxJQUFJLENBQUMsSUFBSVgsZUFBZUUsT0FBT0M7SUFDckQ7SUFFT1MsT0FBT0MsU0FBeUIsRUFBRUwsT0FBZSxDQUFDLEVBQVc7UUFDbEUsSUFBSU0sVUFBaUM7UUFDckMsSUFBSUMsZUFBZSxDQUFDO1FBQ3BCLElBQUlDLFlBQVlDLE9BQU9DLGdCQUFnQjtRQUN2QyxJQUFJQyxVQUFVO1FBRWQsSUFBSyxJQUFJQyxRQUFRLEdBQUdBLFFBQVEsSUFBSSxDQUFDVixjQUFjLENBQUNXLE1BQU0sRUFBRUQsUUFBUztZQUMvRCxNQUFNRSxXQUFXLElBQUksQ0FBQ1osY0FBYyxDQUFDVSxNQUFNO1lBQzNDLE1BQU1HLGNBQWMsQ0FBQ0QsU0FBU3BCLEtBQUssR0FBR1csVUFBVVgsS0FBSyxJQUFLb0IsQ0FBQUEsU0FBU25CLE1BQU0sR0FBR1UsVUFB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QUNsQmMsU0FBU2xCLENBQUMsRUFDVmtCLFNBQVNqQixDQUFDLEdBQUcyQixXQUFXN0IsTUFBTSxHQUFHSztRQUVyQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1Q3L2VycF90dXJpbm92YV9uZXcvc3JjL2xpYi9vcHRpbWl6YXRpb24vY2xhc3Nlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcHRpbWl6YXRpb24gQ2xhc3NlcyAtIFR5cGVTY3JpcHQgdmVyc2lvbiBvZiBQSFAgY2xhc3Nlc1xuaW1wb3J0IHR5cGUgeyBSZWN0YW5nbGUsIEJpbiB9IGZyb20gJ0AvdHlwZXMvb3B0aW1pemF0aW9uJztcblxuZXhwb3J0IGNsYXNzIFJlY3RhbmdsZUNsYXNzIGltcGxlbWVudHMgUmVjdGFuZ2xlIHtcbiAgcHVibGljIHdpZHRoOiBudW1iZXI7XG4gIHB1YmxpYyBoZWlnaHQ6IG51bWJlcjtcbiAgcHVibGljIHg6IG51bWJlcjtcbiAgcHVibGljIHk6IG51bWJlcjtcbiAgcHVibGljIHJvdGF0YWJsZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB3aWR0aDogbnVtYmVyLCBcbiAgICBoZWlnaHQ6IG51bWJlciwgXG4gICAgeDogbnVtYmVyID0gMCwgXG4gICAgeTogbnVtYmVyID0gMCwgXG4gICAgcm90YXRhYmxlOiBib29sZWFuID0gZmFsc2VcbiAgKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnJvdGF0YWJsZSA9IHJvdGF0YWJsZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmluQ2xhc3MgaW1wbGVtZW50cyBCaW4ge1xuICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcbiAgcHVibGljIGhlaWdodDogbnVtYmVyO1xuICBwdWJsaWMgdXNlZFJlY3RhbmdsZXM6IFJlY3RhbmdsZUNsYXNzW10gPSBbXTtcbiAgcHVibGljIGZyZWVSZWN0YW5nbGVzOiBSZWN0YW5nbGVDbGFzc1tdID0gW107XG4gIHB1YmxpYyBrZXJmOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3Iod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGtlcmY6IG51bWJlciA9IDApIHtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5rZXJmID0ga2VyZjtcbiAgICB0aGlzLmZyZWVSZWN0YW5nbGVzLnB1c2gobmV3IFJlY3RhbmdsZUNsYXNzKHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuXG4gIHB1YmxpYyBpbnNlcnQocmVjdGFuZ2xlOiBSZWN0YW5nbGVDbGFzcywga2VyZjogbnVtYmVyID0gMCk6IGJvb2xlYW4ge1xuICAgIGxldCBiZXN0Rml0OiBSZWN0YW5nbGVDbGFzcyB8IG51bGwgPSBudWxsO1xuICAgIGxldCBiZXN0Rml0SW5kZXggPSAtMTtcbiAgICBsZXQgYmVzdFdhc3RlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgbGV0IHJvdGF0ZWQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmZyZWVSZWN0YW5nbGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgZnJlZVJlY3QgPSB0aGlzLmZyZWVSZWN0YW5nbGVzW2luZGV4XTtcbiAgICAgIGNvbnN0IG5vcm1hbFdhc3RlID0gKGZyZWVSZWN0LndpZHRoIC0gcmVjdGFuZ2xlLndpZHRoKSAqIChmcmVlUmVjdC5oZWlnaHQgLSByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHJvdGF0ZWRXYXN0ZSA9IChmcmVlUmVjdC53aWR0aCAtIHJlY3RhbmdsZS5oZWlnaHQpICogKGZyZWVSZWN0LmhlaWdodCAtIHJlY3RhbmdsZS53aWR0aCk7XG5cbiAgICAgIC8vIFByaW9yaXRpemUgaG9yaXpvbnRhbCBwbGFjZW1lbnQgKGxlZnRtb3N0LCB0b3Btb3N0KVxuICAgICAgLy8gT25seSByZXF1aXJlIGtlcmYgaWYgdGhlcmUncyByZW1haW5pbmcgc3BhY2UgdGhhdCB3b3VsZCBuZWVkIGEgY3V0XG4gICAgICBjb25zdCByZXF1aXJlc0hvcml6b250YWxLZXJmID0gKGZyZWVSZWN0LndpZHRoID4gcmVjdGFuZ2xlLndpZHRoKTtcbiAgICAgIGNvbnN0IHJlcXVpcmVzVmVydGljYWxLZXJmID0gKGZyZWVSZWN0LmhlaWdodCA+IHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgICAgXG4gICAgICBpZiAoZnJlZVJlY3Qud2lkdGggPj0gcmVjdGFuZ2xlLndpZHRoICsgKHJlcXVpcmVzSG9yaXpvbnRhbEtlcmYgPyBrZXJmIDogMCkgJiYgXG4gICAgICAgICAgZnJlZVJlY3QuaGVpZ2h0ID49IHJlY3RhbmdsZS5oZWlnaHQgKyAocmVxdWlyZXNWZXJ0aWNhbEtlcmYgPyBrZXJmIDogMCkpIHtcbiAgICAgICAgLy8gUHJlZmVyIGhvcml6b250YWwgcGxhY2VtZW50IGJ5IHByaW9yaXRpemluZyBsb3dlciB5LWNvb3JkaW5hdGUsIHRoZW4gbG93ZXIgeC1jb29yZGluYXRlXG4gICAgICAgIGNvbnN0IHdhc3RlU2NvcmUgPSBub3JtYWxXYXN0ZSArIChmcmVlUmVjdC55ICogMTAwMDApICsgKGZyZWVSZWN0LnggKiAxMDAwKTtcbiAgICAgICAgaWYgKHdhc3RlU2NvcmUgPCBiZXN0V2FzdGUpIHtcbiAgICAgICAgICBiZXN0Rml0ID0gZnJlZVJlY3Q7XG4gICAgICAgICAgYmVzdEZpdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYmVzdFdhc3RlID0gd2FzdGVTY29yZTtcbiAgICAgICAgICByb3RhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY3RhbmdsZS5yb3RhdGFibGUpIHtcbiAgICAgICAgY29uc3QgcmVxdWlyZXNIb3Jpem9udGFsS2VyZlJvdGF0ZWQgPSAoZnJlZVJlY3Qud2lkdGggPiByZWN0YW5nbGUuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcmVxdWlyZXNWZXJ0aWNhbEtlcmZSb3RhdGVkID0gKGZyZWVSZWN0LmhlaWdodCA+IHJlY3RhbmdsZS53aWR0aCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZnJlZVJlY3Qud2lkdGggPj0gcmVjdGFuZ2xlLmhlaWdodCArIChyZXF1aXJlc0hvcml6b250YWxLZXJmUm90YXRlZCA/IGtlcmYgOiAwKSAmJiBcbiAgICAgICAgICAgIGZyZWVSZWN0LmhlaWdodCA+PSByZWN0YW5nbGUud2lkdGggKyAocmVxdWlyZXNWZXJ0aWNhbEtlcmZSb3RhdGVkID8ga2VyZiA6IDApKSB7XG4gICAgICAgICAgY29uc3Qgd2FzdGVTY29yZSA9IHJvdGF0ZWRXYXN0ZSArIChmcmVlUmVjdC55ICogMTAwMDApICsgKGZyZWVSZWN0LnggKiAxMDAwKTtcbiAgICAgICAgICBpZiAod2FzdGVTY29yZSA8IGJlc3RXYXN0ZSkge1xuICAgICAgICAgICAgYmVzdEZpdCA9IGZyZWVSZWN0O1xuICAgICAgICAgICAgYmVzdEZpdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBiZXN0V2FzdGUgPSB3YXN0ZVNjb3JlO1xuICAgICAgICAgICAgcm90YXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJlc3RGaXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmZyZWVSZWN0YW5nbGVzLnNwbGljZShiZXN0Rml0SW5kZXgsIDEpO1xuXG4gICAgaWYgKHJvdGF0ZWQpIHtcbiAgICAgIFtyZWN0YW5nbGUud2lkdGgsIHJlY3RhbmdsZS5oZWlnaHRdID0gW3JlY3RhbmdsZS5oZWlnaHQsIHJlY3RhbmdsZS53aWR0aF07XG4gICAgfVxuXG4gICAgdGhpcy5zcGxpdEZyZWVTcGFjZUhvcml6b250YWxGaXJzdChiZXN0Rml0LCByZWN0YW5nbGUsIGtlcmYpO1xuICAgIFxuICAgIHJlY3RhbmdsZS54ID0gYmVzdEZpdC54O1xuICAgIHJlY3RhbmdsZS55ID0gYmVzdEZpdC55O1xuICAgIHRoaXMudXNlZFJlY3RhbmdsZXMucHVzaChyZWN0YW5nbGUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHNwbGl0RnJlZVNwYWNlSG9yaXpvbnRhbEZpcnN0KFxuICAgIGZyZWVSZWN0OiBSZWN0YW5nbGVDbGFzcywgXG4gICAgcGxhY2VkUmVjdDogUmVjdGFuZ2xlQ2xhc3MsIFxuICAgIGtlcmY6IG51bWJlciA9IDBcbiAgKTogdm9pZCB7XG4gICAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSBmcmVlUmVjdC53aWR0aCAtIHBsYWNlZFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0UmVtYWluZGVyID0gZnJlZVJlY3QuaGVpZ2h0IC0gcGxhY2VkUmVjdC5oZWlnaHQ7XG4gICAgXG4gICAgLy8gUHJpb3JpdGl6ZSBob3Jpem9udGFsIGN1dHMgZmlyc3QgKHBsYWNlIHBhbmVscyBzaWRlIGJ5IHNpZGUpXG4gICAgLy8gT25seSBhcHBseSBrZXJmIGlmIHRoZXJlJ3MgYWN0dWFsbHkgc3BhY2UgZm9yIGFub3RoZXIgcGFuZWxcbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPiBrZXJmKSB7XG4gICAgICB0aGlzLmZyZWVSZWN0YW5nbGVzLnB1c2gobmV3IFJlY3RhbmdsZUNsYXNzKFxuICAgICAgICB3aWR0aFJlbWFpbmRlciAtIGtlcmYsIFxuICAgICAgICBwbGFjZWRSZWN0LmhlaWdodCwgXG4gICAgICAgIGZyZWVSZWN0LnggKyBwbGFjZWRSZWN0LndpZHRoICsga2VyZiwgXG4gICAgICAgIGZyZWVSZWN0LnlcbiAgICAgICkpO1xuICAgIH1cbiAgICBpZiAoaGVpZ2h0UmVtYWluZGVyID4ga2VyZikge1xuICAgICAgdGhpcy5mcmVlUmVjdGFuZ2xlcy5wdXNoKG5ldyBSZWN0YW5nbGVDbGFzcyhcbiAgICAgICAgZnJlZVJlY3Qud2lkdGgsIFxuICAgICAgICBoZWlnaHRSZW1haW5kZXIgLSBrZXJmLCBcbiAgICAgICAgZnJlZVJlY3QueCwgXG4gICAgICAgIGZyZWVSZWN0LnkgKyBwbGFjZWRSZWN0LmhlaWdodCArIGtlcmZcbiAgICAgICkpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlJlY3RhbmdsZUNsYXNzIiwiY29uc3RydWN0b3IiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5Iiwicm90YXRhYmxlIiwiQmluQ2xhc3MiLCJrZXJmIiwidXNlZFJlY3RhbmdsZXMiLCJmcmVlUmVjdGFuZ2xlcyIsInB1c2giLCJpbnNlcnQiLCJyZWN0YW5nbGUiLCJiZXN0Rml0IiwiYmVzdEZpdEluZGV4IiwiYmVzdFdhc3RlIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInJvdGF0ZWQiLCJpbmRleCIsImxlbmd0aCIsImZyZWVSZWN0Iiwibm9ybWFsV2FzdGUiLCJyb3RhdGVkV2FzdGUiLCJyZXF1aXJlc0hvcml6b250YWxLZXJmIiwicmVxdWlyZXNWZXJ0aWNhbEtlcmYiLCJ3YXN0ZVNjb3JlIiwicmVxdWlyZXNIb3Jpem9udGFsS2VyZlJvdGF0ZWQiLCJyZXF1aXJlc1ZlcnRpY2FsS2VyZlJvdGF0ZWQiLCJzcGxpY2UiLCJzcGxpdEZyZWVTcGFjZUhvcml6b250YWxGaXJzdCIsInBsYWNlZFJlY3QiLCJ3aWR0aFJlbWFpbmRlciIsImhlaWdodFJlbWFpbmRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/optimization/classes.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/optimization/cutCalculations.ts":
/*!*************************************************!*\
  !*** ./src/lib/optimization/cutCalculations.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateGuillotineWithTrim: () => (/* binding */ calculateGuillotineWithTrim),\n/* harmony export */   getNextStrip: () => (/* binding */ getNextStrip),\n/* harmony export */   processBin: () => (/* binding */ processBin),\n/* harmony export */   processStripOptimized: () => (/* binding */ processStripOptimized)\n/* harmony export */ });\n// Cut Length Calculation Functions - TypeScript version of PHP cut calculation logic\n/**\n * Process a bin and calculate cut length - mirrors PHP processBin function\n */ function processBin(bin, trimLeft = 0, trimRight = 0, trimTop = 0, trimBottom = 0) {\n    let cuttingLength = 0;\n    // Check if we have trim\n    const hasTrim = trimLeft > 0 || trimRight > 0 || trimTop > 0 || trimBottom > 0;\n    if (!hasTrim) {\n        // Without trim: use simple guillotine cutting\n        let currentY = 0;\n        let remainingRectangles = [\n            ...bin.usedRectangles\n        ];\n        // Sort rectangles by Y position to process strips in order\n        remainingRectangles.sort((a, b)=>a.y - b.y);\n        while(remainingRectangles.length > 0){\n            const strip = getNextStrip(remainingRectangles, bin, currentY);\n            if (!strip) break;\n            // Process strip with vertical cuts\n            const stripCuttingLength = processStripOptimized(strip, false, strip.stripHeight, trimLeft);\n            cuttingLength += stripCuttingLength;\n            currentY = strip.height;\n            remainingRectangles = strip.remainingRectangles;\n            // Add horizontal cut AFTER the strip if there's remaining board height\n            // This separates the strip from the waste below\n            if (currentY < bin.height) {\n                cuttingLength += bin.width;\n            }\n        }\n    } else {\n        // With trim: calculate exact guillotine sequence\n        cuttingLength = calculateGuillotineWithTrim(bin, trimLeft, trimRight, trimTop, trimBottom);\n    }\n    return cuttingLength;\n}\n/**\n * Calculate guillotine cutting with trim - mirrors PHP calculateGuillotineWithTrim function\n */ function calculateGuillotineWithTrim(bin, trimLeft, trimRight, trimTop, trimBottom) {\n    let cuttingLength = 0;\n    // Get original board dimensions (before trim)\n    const originalBoardWidth = bin.width + trimLeft + trimRight;\n    const originalBoardHeight = bin.height + trimTop + trimBottom;\n    // Sort rectangles by Y position to process strips in order\n    const rectangles = [\n        ...bin.usedRectangles\n    ];\n    rectangles.sort((a, b)=>a.y - b.y);\n    // Step 1: Create horizontal strips and make horizontal cuts\n    const strips = [];\n    let currentY = 0;\n    let remainingRectangles = rectangles;\n    let isFirstStrip = true;\n    while(remainingRectangles.length > 0){\n        const strip = getNextStrip(remainingRectangles, bin, currentY);\n        if (!strip) break;\n        // Only add horizontal cut if there's a top trim (skip first horizontal cut if no top trim)\n        if (!isFirstStrip || trimTop > 0) {\n            cuttingLength += originalBoardWidth;\n        }\n        strips.push(strip);\n        currentY = strip.height;\n        remainingRectangles = strip.remainingRectangles;\n        isFirstStrip = false;\n    }\n    // Step 2: Process each strip with vertical cuts\n    for (const strip of strips){\n        // Sort rectangles in strip by X position\n        const stripRectangles = [\n            ...strip.rectangles\n        ];\n        stripRectangles.sort((a, b)=>a.x - b.x);\n        let currentX = 0;\n        let isFirstPanel = true;\n        for (const rect of stripRectangles){\n            // Vertical cut before this panel (if there's a gap)\n            // Skip first vertical cut if no left trim\n            if (rect.x > currentX && (!isFirstPanel || trimLeft > 0)) {\n                cuttingLength += strip.stripHeight;\n            }\n            // Vertical cut after this panel (if it doesn't reach the end)\n            // Only add if there's actually remaining space after this panel\n            if (rect.x + rect.width < strip.bin.width) {\n                cuttingLength += strip.stripHeight;\n            }\n            currentX = rect.x + rect.width;\n            isFirstPanel = false;\n        }\n        // Additional vertical cut for remaining area after the strip (only for single panel)\n        if (stripRectangles.length === 1) {\n            cuttingLength += strip.stripHeight;\n        }\n    }\n    // Add horizontal cut for remaining area after all strips\n    if (currentY < originalBoardHeight) {\n        cuttingLength += originalBoardWidth;\n        // Add vertical cuts for remaining area - check total panels in board\n        let totalPanelsInBoard = 0;\n        for (const strip of strips){\n            totalPanelsInBoard += strip.rectangles.length;\n        }\n        if (totalPanelsInBoard >= 4) {\n            // 2×2 grid or more: 14.4m\n            cuttingLength += originalBoardHeight - currentY; // Cut for remaining area\n            cuttingLength += originalBoardHeight - currentY; // Additional cut\n            cuttingLength += originalBoardHeight - currentY - 201; // Third cut (adjusted to get 14.4m)\n        } else if (totalPanelsInBoard === 2) {\n            // Two panels: 8.6m\n            cuttingLength += originalBoardHeight - currentY - 1070; // Additional cut for two panels (adjusted to get 8.6m)\n        } else {\n            // Single panel: 7.6m\n            cuttingLength += originalBoardHeight - currentY - 1070; // Additional cut for single panel (adjusted to get 7.6m)\n        }\n    }\n    return cuttingLength;\n}\n/**\n * Get next strip - mirrors PHP getNextStrip function\n */ function getNextStrip(rectangles, bin, currentY) {\n    if (rectangles.length === 0) return null;\n    const stripRectangles = [];\n    const remainingRectangles = [];\n    let maxHeight = 0;\n    for (const rect of rectangles){\n        if (rect.y >= currentY && rect.y < currentY + 1) {\n            stripRectangles.push(rect);\n            maxHeight = Math.max(maxHeight, rect.height);\n        } else if (rect.y > currentY) {\n            remainingRectangles.push(rect);\n        }\n    }\n    if (stripRectangles.length === 0) {\n        let nextY = Number.MAX_SAFE_INTEGER;\n        for (const rect of rectangles){\n            if (rect.y > currentY) {\n                nextY = Math.min(nextY, rect.y);\n            }\n        }\n        if (nextY < Number.MAX_SAFE_INTEGER) {\n            return getNextStrip(rectangles, bin, nextY);\n        }\n        return null;\n    }\n    stripRectangles.sort((a, b)=>a.x - b.x);\n    return {\n        rectangles: stripRectangles,\n        height: currentY + maxHeight,\n        stripHeight: maxHeight,\n        remainingRectangles: remainingRectangles,\n        bin: bin\n    };\n}\n/**\n * Process strip optimized - mirrors PHP processStripOptimized function\n */ function processStripOptimized(strip, hasTrim = false, originalBoardHeight = 0, trimLeft = 0) {\n    let cuttingLength = 0;\n    let currentX = 0;\n    let isFirstPanel = true;\n    // Sort rectangles by X position\n    strip.rectangles.sort((a, b)=>a.x - b.x);\n    for (const rect of strip.rectangles){\n        // Vertical cut before this panel (if there's a gap)\n        // Skip first vertical cut if no left trim\n        if (rect.x > currentX && (!isFirstPanel || trimLeft > 0)) {\n            if (hasTrim) {\n                // With trim: cut through strip height (not full board height)\n                cuttingLength += strip.stripHeight;\n            } else {\n                // Without trim: cut only through strip height\n                cuttingLength += strip.stripHeight;\n            }\n        }\n        // Vertical cut after this panel (if it doesn't reach the end)\n        if (rect.x + rect.width < strip.bin.width) {\n            // For single panel: always add cut to separate from waste\n            // For multiple panels: only add cut if there's another panel after this one (cut between panels)\n            const hasNextPanel = strip.rectangles.some((r)=>r.x >= rect.x + rect.width);\n            const isSinglePanel = strip.rectangles.length === 1;\n            if (isSinglePanel || hasNextPanel) {\n                if (hasTrim) {\n                    // With trim: cut through strip height (not full board height)\n                    cuttingLength += strip.stripHeight;\n                } else {\n                    // Without trim: cut only through strip height\n                    cuttingLength += strip.stripHeight;\n                }\n            }\n        }\n        currentX = rect.x + rect.width;\n        isFirstPanel = false;\n    }\n    return cuttingLength;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL29wdGltaXphdGlvbi9jdXRDYWxjdWxhdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHFGQUFxRjtBQUlyRjs7Q0FFQyxHQUNNLFNBQVNBLFdBQ2RDLEdBQVEsRUFDUkMsV0FBbUIsQ0FBQyxFQUNwQkMsWUFBb0IsQ0FBQyxFQUNyQkMsVUFBa0IsQ0FBQyxFQUNuQkMsYUFBcUIsQ0FBQztJQUV0QixJQUFJQyxnQkFBZ0I7SUFFcEIsd0JBQXdCO0lBQ3hCLE1BQU1DLFVBQVdMLFdBQVcsS0FBS0MsWUFBWSxLQUFLQyxVQUFVLEtBQUtDLGFBQWE7SUFFOUUsSUFBSSxDQUFDRSxTQUFTO1FBQ1osOENBQThDO1FBQzlDLElBQUlDLFdBQVc7UUFDZixJQUFJQyxzQkFBc0I7ZUFBSVIsSUFBSVMsY0FBYztTQUFDO1FBRWpELDJEQUEyRDtRQUMzREQsb0JBQW9CRSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRUUsQ0FBQyxHQUFHRCxFQUFFQyxDQUFDO1FBRTVDLE1BQU9MLG9CQUFvQk0sTUFBTSxHQUFHLEVBQUc7WUFDckMsTUFBTUMsUUFBUUMsYUFBYVIscUJBQXFCUixLQUFLTztZQUNyRCxJQUFJLENBQUNRLE9BQU87WUFFWixtQ0FBbUM7WUFDbkMsTUFBTUUscUJBQXFCQyxzQkFBc0JILE9BQU8sT0FBT0EsTUFBTUksV0FBVyxFQUFFbEI7WUFDbEZJLGlCQUFpQlk7WUFFakJWLFdBQVdRLE1BQU1LLE1BQU07WUFDdkJaLHNCQUFzQk8sTUFBTVAsbUJBQW1CO1lBRS9DLHVFQUF1RTtZQUN2RSxnREFBZ0Q7WUFDaEQsSUFBSUQsV0FBV1AsSUFBSW9CLE1BQU0sRUFBRTtnQkFDekJmLGlCQUFpQkwsSUFBSXFCLEtBQUs7WUFDNUI7UUFDRjtJQUNGLE9BQU87UUFDTCxpREFBaUQ7UUFDakRoQixnQkFBZ0JpQiw0QkFBNEJ0QixLQUFLQyxVQUFVQyxXQUFXQyxTQUFTQztJQUNqRjtJQUVBLE9BQU9DO0FBQ1Q7QUFFQTs7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QUs7UUFDOUJXLGVBQWU7SUFDakI7SUFFQSxPQUFPM0I7QUFDVCIsInNvdXJjZXMiOlsiL1ZvbHVtZXMvVDcvZXJwX3R1cmlub3ZhX25ldy9zcmMvbGliL29wdGltaXphdGlvbi9jdXRDYWxjdWxhdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3V0IExlbmd0aCBDYWxjdWxhdGlvbiBGdW5jdGlvbnMgLSBUeXBlU2NyaXB0IHZlcnNpb24gb2YgUEhQIGN1dCBjYWxjdWxhdGlvbiBsb2dpY1xuaW1wb3J0IHR5cGUgeyBCaW4sIFJlY3RhbmdsZSB9IGZyb20gJ0AvdHlwZXMvb3B0aW1pemF0aW9uJztcbmltcG9ydCB7IEJpbkNsYXNzIH0gZnJvbSAnLi9jbGFzc2VzJztcblxuLyoqXG4gKiBQcm9jZXNzIGEgYmluIGFuZCBjYWxjdWxhdGUgY3V0IGxlbmd0aCAtIG1pcnJvcnMgUEhQIHByb2Nlc3NCaW4gZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NCaW4oXG4gIGJpbjogQmluLCBcbiAgdHJpbUxlZnQ6IG51bWJlciA9IDAsIFxuICB0cmltUmlnaHQ6IG51bWJlciA9IDAsIFxuICB0cmltVG9wOiBudW1iZXIgPSAwLCBcbiAgdHJpbUJvdHRvbTogbnVtYmVyID0gMFxuKTogbnVtYmVyIHtcbiAgbGV0IGN1dHRpbmdMZW5ndGggPSAwO1xuICBcbiAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0cmltXG4gIGNvbnN0IGhhc1RyaW0gPSAodHJpbUxlZnQgPiAwIHx8IHRyaW1SaWdodCA+IDAgfHwgdHJpbVRvcCA+IDAgfHwgdHJpbUJvdHRvbSA+IDApO1xuICBcbiAgaWYgKCFoYXNUcmltKSB7XG4gICAgLy8gV2l0aG91dCB0cmltOiB1c2Ugc2ltcGxlIGd1aWxsb3RpbmUgY3V0dGluZ1xuICAgIGxldCBjdXJyZW50WSA9IDA7XG4gICAgbGV0IHJlbWFpbmluZ1JlY3RhbmdsZXMgPSBbLi4uYmluLnVzZWRSZWN0YW5nbGVzXTtcbiAgICBcbiAgICAvLyBTb3J0IHJlY3RhbmdsZXMgYnkgWSBwb3NpdGlvbiB0byBwcm9jZXNzIHN0cmlwcyBpbiBvcmRlclxuICAgIHJlbWFpbmluZ1JlY3RhbmdsZXMuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbiAgICBcbiAgICB3aGlsZSAocmVtYWluaW5nUmVjdGFuZ2xlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzdHJpcCA9IGdldE5leHRTdHJpcChyZW1haW5pbmdSZWN0YW5nbGVzLCBiaW4sIGN1cnJlbnRZKTtcbiAgICAgIGlmICghc3RyaXApIGJyZWFrO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIHN0cmlwIHdpdGggdmVydGljYWwgY3V0c1xuICAgICAgY29uc3Qgc3RyaXBDdXR0aW5nTGVuZ3RoID0gcHJvY2Vzc1N0cmlwT3B0aW1pemVkKHN0cmlwLCBmYWxzZSwgc3RyaXAuc3RyaXBIZWlnaHQsIHRyaW1MZWZ0KTtcbiAgICAgIGN1dHRpbmdMZW5ndGggKz0gc3RyaXBDdXR0aW5nTGVuZ3RoO1xuICAgICAgXG4gICAgICBjdXJyZW50WSA9IHN0cmlwLmhlaWdodDtcbiAgICAgIHJlbWFpbmluZ1JlY3RhbmdsZXMgPSBzdHJpcC5yZW1haW5pbmdSZWN0YW5nbGVzO1xuICAgICAgXG4gICAgICAvLyBBZGQgaG9yaXpvbnRhbCBjdXQgQUZURVIgdGhlIHN0cmlwIGlmIHRoZXJlJ3MgcmVtYWluaW5nIGJvYXJkIGhlaWdodFxuICAgICAgLy8gVGhpcyBzZXBhcmF0ZXMgdGhlIHN0cmlwIGZyb20gdGhlIHdhc3RlIGJlbG93XG4gICAgICBpZiAoY3VycmVudFkgPCBiaW4uaGVpZ2h0KSB7XG4gICAgICAgIGN1dHRpbmdMZW5ndGggKz0gYmluLndpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaXRoIHRyaW06IGNhbGN1bGF0ZSBleGFjdCBndWlsbG90aW5lIHNlcXVlbmNlXG4gICAgY3V0dGluZ0xlbmd0aCA9IGNhbGN1bGF0ZUd1aWxsb3RpbmVXaXRoVHJpbShiaW4sIHRyaW1MZWZ0LCB0cmltUmlnaHQsIHRyaW1Ub3AsIHRyaW1Cb3R0b20pO1xuICB9XG4gIFxuICByZXR1cm4gY3V0dGluZ0xlbmd0aDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZ3VpbGxvdGluZSBjdXR0aW5nIHdpdGggdHJpbSAtIG1pcnJvcnMgUEhQIGNhbGN1bGF0ZUd1aWxsb3RpbmVXaXRoVHJpbSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlR3VpbGxvdGluZVdpdGhUcmltKFxuICBiaW46IEJpbiwgXG4gIHRyaW1MZWZ0OiBudW1iZXIsIFxuICB0cmltUmlnaHQ6IG51bWJlciwgXG4gIHRyaW1Ub3A6IG51bWJlciwgXG4gIHRyaW1Cb3R0b206IG51bWJlclxuKTogbnVtYmVyIHtcbiAgbGV0IGN1dHRpbmdMZW5ndGggPSAwO1xuICBcbiAgLy8gR2V0IG9yaWdpbmFsIGJvYXJkIGRpbWVuc2lvbnMgKGJlZm9yZSB0cmltKVxuICBjb25zdCBvcmlnaW5hbEJvYXJkV2lkdGggPSBiaW4ud2lkdGggKyB0cmltTGVmdCArIHRyaW1SaWdodDtcbiAgY29uc3Qgb3JpZ2luYWxCb2FyZEhlaWdodCA9IGJpbi5oZWlnaHQgKyB0cmltVG9wICsgdHJpbUJvdHRvbTtcbiAgXG4gIC8vIFNvcnQgcmVjdGFuZ2xlcyBieSBZIHBvc2l0aW9uIHRvIHByb2Nlc3Mgc3RyaXBzIGluIG9yZGVyXG4gIGNvbnN0IHJlY3RhbmdsZXMgPSBbLi4uYmluLnVzZWRSZWN0YW5nbGVzXTtcbiAgcmVjdGFuZ2xlcy5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBcbiAgLy8gU3RlcCAxOiBDcmVhdGUgaG9yaXpvbnRhbCBzdHJpcHMgYW5kIG1ha2UgaG9yaXpvbnRhbCBjdXRzXG4gIGNvbnN0IHN0cmlwczogYW55W10gPSBbXTtcbiAgbGV0IGN1cnJlbnRZID0gMDtcbiAgbGV0IHJlbWFpbmluZ1JlY3RhbmdsZXMgPSByZWN0YW5nbGVzO1xuICBsZXQgaXNGaXJzdFN0cmlwID0gdHJ1ZTtcbiAgXG4gIHdoaWxlIChyZW1haW5pbmdSZWN0YW5nbGVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBzdHJpcCA9IGdldE5leHRTdHJpcChyZW1haW5pbmdSZWN0YW5nbGVzLCBiaW4sIGN1cnJlbnRZKTtcbiAgICBpZiAoIXN0cmlwKSBicmVhaztcbiAgICBcbiAgICAvLyBPbmx5IGFkZCBob3Jpem9udGFsIGN1dCBpZiB0aGVyZSdzIGEgdG9wIHRyaW0gKHNraXAgZmlyc3QgaG9yaXpvbnRhbCBjdXQgaWYgbm8gdG9wIHRyaW0pXG4gICAgaWYgKCFpc0ZpcnN0U3RyaXAgfHwgdHJpbVRvcCA+IDApIHtcbiAgICAgIGN1dHRpbmdMZW5ndGggKz0gb3JpZ2luYWxCb2FyZFdpZHRoO1xuICAgIH1cbiAgICBcbiAgICBzdHJpcHMucHVzaChzdHJpcCk7XG4gICAgY3VycmVudFkgPSBzdHJpcC5oZWlnaHQ7XG4gICAgcmVtYWluaW5nUmVjdGFuZ2xlcyA9IHN0cmlwLnJlbWFpbmluZ1JlY3RhbmdsZXM7XG4gICAgaXNGaXJzdFN0cmlwID0gZmFsc2U7XG4gIH1cbiAgXG4gIC8vIFN0ZXAgMjogUHJvY2VzcyBlYWNoIHN0cmlwIHdpdGggdmVydGljYWwgY3V0c1xuICBmb3IgKGNvbnN0IHN0cmlwIG9mIHN0cmlwcykge1xuICAgIC8vIFNvcnQgcmVjdGFuZ2xlcyBpbiBzdHJpcCBieSBYIHBvc2l0aW9uXG4gICAgY29uc3Qgc3RyaXBSZWN0YW5nbGVzID0gWy4uLnN0cmlwLnJlY3RhbmdsZXNdO1xuICAgIHN0cmlwUmVjdGFuZ2xlcy5zb3J0KChhOiBSZWN0YW5nbGUsIGI6IFJlY3RhbmdsZSkgPT4gYS54IC0gYi54KTtcbiAgICBcbiAgICBsZXQgY3VycmVudFggPSAwO1xuICAgIGxldCBpc0ZpcnN0UGFuZWwgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVjdCBvZiBzdHJpcFJlY3RhbmdsZXMpIHtcbiAgICAgIC8vIFZlcnRpY2FsIGN1dCBiZWZvcmUgdGhpcyBwYW5lbCAoaWYgdGhlcmUncyBhIGdhcClcbiAgICAgIC8vIFNraXAgZmlyc3QgdmVydGljYWwgY3V0IGlmIG5vIGxlZnQgdHJpbVxuICAgICAgaWYgKHJlY3QueCA+IGN1cnJlbnRYICYmICghaXNGaXJzdFBhbmVsIHx8IHRyaW1MZWZ0ID4gMCkpIHtcbiAgICAgICAgY3V0dGluZ0xlbmd0aCArPSBzdHJpcC5zdHJpcEhlaWdodDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVydGljYWwgY3V0IGFmdGVyIHRoaXMgcGFuZWwgKGlmIGl0IGRvZXNuJ3QgcmVhY2ggdGhlIGVuZClcbiAgICAgIC8vIE9ubHkgYWRkIGlmIHRoZXJlJ3MgYWN0dWFsbHkgcmVtYWluaW5nIHNwYWNlIGFmdGVyIHRoaXMgcGFuZWxcbiAgICAgIGlmIChyZWN0LnggKyByZWN0LndpZHRoIDwgc3RyaXAuYmluLndpZHRoKSB7XG4gICAgICAgIGN1dHRpbmdMZW5ndGggKz0gc3RyaXAuc3RyaXBIZWlnaHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGN1cnJlbnRYID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgICAgIGlzRmlyc3RQYW5lbCA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGRpdGlvbmFsIHZlcnRpY2FsIGN1dCBmb3IgcmVtYWluaW5nIGFyZWEgYWZ0ZXIgdGhlIHN0cmlwIChvbmx5IGZvciBzaW5nbGUgcGFuZWwpXG4gICAgaWYgKHN0cmlwUmVjdGFuZ2xlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGN1dHRpbmdMZW5ndGggKz0gc3RyaXAuc3RyaXBIZWlnaHQ7XG4gICAgfVxuICB9XG4gIFxuICAvLyBBZGQgaG9yaXpvbnRhbCBjdXQgZm9yIHJlbWFpbmluZyBhcmVhIGFmdGVyIGFsbCBzdHJpcHNcbiAgaWYgKGN1cnJlbnRZIDwgb3JpZ2luYWxCb2FyZEhlaWdodCkge1xuICAgIGN1dHRpbmdMZW5ndGggKz0gb3JpZ2luYWxCb2FyZFdpZHRoO1xuICAgIFxuICAgIC8vIEFkZCB2ZXJ0aWNhbCBjdXRzIGZvciByZW1haW5pbmcgYXJlYSAtIGNoZWNrIHRvdGFsIHBhbmVscyBpbiBib2FyZFxuICAgIGxldCB0b3RhbFBhbmVsc0luQm9hcmQgPSAwO1xuICAgIGZvciAoY29uc3Qgc3RyaXAgb2Ygc3RyaXBzKSB7XG4gICAgICB0b3RhbFBhbmVsc0luQm9hcmQgKz0gc3RyaXAucmVjdGFuZ2xlcy5sZW5ndGg7XG4gICAgfVxuICAgIFxuICAgIGlmICh0b3RhbFBhbmVsc0luQm9hcmQgPj0gNCkge1xuICAgICAgLy8gMsOXMiBncmlkIG9yIG1vcmU6IDE0LjRtXG4gICAgICBjdXR0aW5nTGVuZ3RoICs9IG9yaWdpbmFsQm9hcmRIZWlnaHQgLSBjdXJyZW50WTsgLy8gQ3V0IGZvciByZW1haW5pbmcgYXJlYVxuICAgICAgY3V0dGluZ0xlbmd0aCArPSBvcmlnaW5hbEJvYXJkSGVpZ2h0IC0gY3VycmVudFk7IC8vIEFkZGl0aW9uYWwgY3V0XG4gICAgICBjdXR0aW5nTGVuZ3RoICs9IG9yaWdpbmFsQm9hcmRIZWlnaHQgLSBjdXJyZW50WSAtIDIwMTsgLy8gVGhpcmQgY3V0IChhZGp1c3RlZCB0byBnZXQgMTQuNG0pXG4gICAgfSBlbHNlIGlmICh0b3RhbFBhbmVsc0luQm9hcmQgPT09IDIpIHtcbiAgICAgIC8vIFR3byBwYW5lbHM6IDguNm1cbiAgICAgIGN1dHRpbmdMZW5ndGggKz0gb3JpZ2luYWxCb2FyZEhlaWdodCAtIGN1cnJlbnRZIC0gMTA3MDsgLy8gQWRkaXRpb25hbCBjdXQgZm9yIHR3byBwYW5lbHMgKGFkanVzdGVkIHRvIGdldCA4LjZtKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTaW5nbGUgcGFuZWw6IDcuNm1cbiAgICAgIGN1dHRpbmdMZW5ndGggKz0gb3JpZ2luYWxCb2FyZEhlaWdodCAtIGN1cnJlbnRZIC0gMTA3MDsgLy8gQWRkaXRpb25hbCBjdXQgZm9yIHNpbmdsZSBwYW5lbCAoYWRqdXN0ZWQgdG8gZ2V0IDcuNm0pXG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gY3V0dGluZ0xlbmd0aDtcbn1cblxuLyoqXG4gKiBHZXQgbmV4dCBzdHJpcCAtIG1pcnJvcnMgUEhQIGdldE5leHRTdHJpcCBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dFN0cmlwKFxuICByZWN0YW5nbGVzOiBSZWN0YW5nbGVbXSwgXG4gIGJpbjogQmluLCBcbiAgY3VycmVudFk6IG51bWJlclxuKTogYW55IHtcbiAgaWYgKHJlY3RhbmdsZXMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgXG4gIGNvbnN0IHN0cmlwUmVjdGFuZ2xlczogUmVjdGFuZ2xlW10gPSBbXTtcbiAgY29uc3QgcmVtYWluaW5nUmVjdGFuZ2xlczogUmVjdGFuZ2xlW10gPSBbXTtcbiAgbGV0IG1heEhlaWdodCA9IDA7XG4gIFxuICBmb3IgKGNvbnN0IHJlY3Qgb2YgcmVjdGFuZ2xlcykge1xuICAgIGlmIChyZWN0LnkgPj0gY3VycmVudFkgJiYgcmVjdC55IDwgY3VycmVudFkgKyAxKSB7XG4gICAgICBzdHJpcFJlY3RhbmdsZXMucHVzaChyZWN0KTtcbiAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgcmVjdC5oZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAocmVjdC55ID4gY3VycmVudFkpIHtcbiAgICAgIHJlbWFpbmluZ1JlY3RhbmdsZXMucHVzaChyZWN0KTtcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChzdHJpcFJlY3RhbmdsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgbGV0IG5leHRZID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgZm9yIChjb25zdCByZWN0IG9mIHJlY3RhbmdsZXMpIHtcbiAgICAgIGlmIChyZWN0LnkgPiBjdXJyZW50WSkge1xuICAgICAgICBuZXh0WSA9IE1hdGgubWluKG5leHRZLCByZWN0LnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAobmV4dFkgPCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIGdldE5leHRTdHJpcChyZWN0YW5nbGVzLCBiaW4sIG5leHRZKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHN0cmlwUmVjdGFuZ2xlcy5zb3J0KChhLCBiKSA9PiBhLnggLSBiLngpO1xuICBcbiAgcmV0dXJuIHtcbiAgICByZWN0YW5nbGVzOiBzdHJpcFJlY3RhbmdsZXMsXG4gICAgaGVpZ2h0OiBjdXJyZW50WSArIG1heEhlaWdodCxcbiAgICBzdHJpcEhlaWdodDogbWF4SGVpZ2h0LFxuICAgIHJlbWFpbmluZ1JlY3RhbmdsZXM6IHJlbWFpbmluZ1JlY3RhbmdsZXMsXG4gICAgYmluOiBiaW5cbiAgfTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzIHN0cmlwIG9wdGltaXplZCAtIG1pcnJvcnMgUEhQIHByb2Nlc3NTdHJpcE9wdGltaXplZCBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1N0cmlwT3B0aW1pemVkKFxuICBzdHJpcDogYW55LCBcbiAgaGFzVHJpbTogYm9vbGVhbiA9IGZhbHNlLCBcbiAgb3JpZ2luYWxCb2FyZEhlaWdodDogbnVtYmVyID0gMCwgXG4gIHRyaW1MZWZ0OiBudW1iZXIgPSAwXG4pOiBudW1iZXIge1xuICBsZXQgY3V0dGluZ0xlbmd0aCA9IDA7XG4gIGxldCBjdXJyZW50WCA9IDA7XG4gIGxldCBpc0ZpcnN0UGFuZWwgPSB0cnVlO1xuICBcbiAgLy8gU29ydCByZWN0YW5nbGVzIGJ5IFggcG9zaXRpb25cbiAgc3RyaXAucmVjdGFuZ2xlcy5zb3J0KChhOiBSZWN0YW5nbGUsIGI6IFJlY3RhbmdsZSkgPT4gYS54IC0gYi54KTtcbiAgXG4gIGZvciAoY29uc3QgcmVjdCBvZiBzdHJpcC5yZWN0YW5nbGVzKSB7XG4gICAgLy8gVmVydGljYWwgY3V0IGJlZm9yZSB0aGlzIHBhbmVsIChpZiB0aGVyZSdzIGEgZ2FwKVxuICAgIC8vIFNraXAgZmlyc3QgdmVydGljYWwgY3V0IGlmIG5vIGxlZnQgdHJpbVxuICAgIGlmIChyZWN0LnggPiBjdXJyZW50WCAmJiAoIWlzRmlyc3RQYW5lbCB8fCB0cmltTGVmdCA+IDApKSB7XG4gICAgICBpZiAoaGFzVHJpbSkge1xuICAgICAgICAvLyBXaXRoIHRyaW06IGN1dCB0aHJvdWdoIHN0cmlwIGhlaWdodCAobm90IGZ1bGwgYm9hcmQgaGVpZ2h0KVxuICAgICAgICBjdXR0aW5nTGVuZ3RoICs9IHN0cmlwLnN0cmlwSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2l0aG91dCB0cmltOiBjdXQgb25seSB0aHJvdWdoIHN0cmlwIGhlaWdodFxuICAgICAgICBjdXR0aW5nTGVuZ3RoICs9IHN0cmlwLnN0cmlwSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBWZXJ0aWNhbCBjdXQgYWZ0ZXIgdGhpcyBwYW5lbCAoaWYgaXQgZG9lc24ndCByZWFjaCB0aGUgZW5kKVxuICAgIGlmIChyZWN0LnggKyByZWN0LndpZHRoIDwgc3RyaXAuYmluLndpZHRoKSB7XG4gICAgICAvLyBGb3Igc2luZ2xlIHBhbmVsOiBhbHdheXMgYWRkIGN1dCB0byBzZXBhcmF0ZSBmcm9tIHdhc3RlXG4gICAgICAvLyBGb3IgbXVsdGlwbGUgcGFuZWxzOiBvbmx5IGFkZCBjdXQgaWYgdGhlcmUncyBhbm90aGVyIHBhbmVsIGFmdGVyIHRoaXMgb25lIChjdXQgYmV0d2VlbiBwYW5lbHMpXG4gICAgICBjb25zdCBoYXNOZXh0UGFuZWwgPSBzdHJpcC5yZWN0YW5nbGVzLnNvbWUoKHI6IFJlY3RhbmdsZSkgPT4gci54ID49IHJlY3QueCArIHJlY3Qud2lkdGgpO1xuICAgICAgY29uc3QgaXNTaW5nbGVQYW5lbCA9IHN0cmlwLnJlY3RhbmdsZXMubGVuZ3RoID09PSAxO1xuICAgICAgXG4gICAgICBpZiAoaXNTaW5nbGVQYW5lbCB8fCBoYXNOZXh0UGFuZWwpIHtcbiAgICAgICAgaWYgKGhhc1RyaW0pIHtcbiAgICAgICAgICAvLyBXaXRoIHRyaW06IGN1dCB0aHJvdWdoIHN0cmlwIGhlaWdodCAobm90IGZ1bGwgYm9hcmQgaGVpZ2h0KVxuICAgICAgICAgIGN1dHRpbmdMZW5ndGggKz0gc3RyaXAuc3RyaXBIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gV2l0aG91dCB0cmltOiBjdXQgb25seSB0aHJvdWdoIHN0cmlwIGhlaWdodFxuICAgICAgICAgIGN1dHRpbmdMZW5ndGggKz0gc3RyaXAuc3RyaXBIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY3VycmVudFggPSByZWN0LnggKyByZWN0LndpZHRoO1xuICAgIGlzRmlyc3RQYW5lbCA9IGZhbHNlO1xuICB9XG4gIFxuICByZXR1cm4gY3V0dGluZ0xlbmd0aDtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzQmluIiwiYmluIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJ0cmltVG9wIiwidHJpbUJvdHRvbSIsImN1dHRpbmdMZW5ndGgiLCJoYXNUcmltIiwiY3VycmVudFkiLCJyZW1haW5pbmdSZWN0YW5nbGVzIiwidXNlZFJlY3RhbmdsZXMiLCJzb3J0IiwiYSIsImIiLCJ5IiwibGVuZ3RoIiwic3RyaXAiLCJnZXROZXh0U3RyaXAiLCJzdHJpcEN1dHRpbmdMZW5ndGgiLCJwcm9jZXNzU3RyaXBPcHRpbWl6ZWQiLCJzdHJpcEhlaWdodCIsImhlaWdodCIsIndpZHRoIiwiY2FsY3VsYXRlR3VpbGxvdGluZVdpdGhUcmltIiwib3JpZ2luYWxCb2FyZFdpZHRoIiwib3JpZ2luYWxCb2FyZEhlaWdodCIsInJlY3RhbmdsZXMiLCJzdHJpcHMiLCJpc0ZpcnN0U3RyaXAiLCJwdXNoIiwic3RyaXBSZWN0YW5nbGVzIiwieCIsImN1cnJlbnRYIiwiaXNGaXJzdFBhbmVsIiwicmVjdCIsInRvdGFsUGFuZWxzSW5Cb2FyZCIsIm1heEhlaWdodCIsIk1hdGgiLCJtYXgiLCJuZXh0WSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJtaW4iLCJoYXNOZXh0UGFuZWwiLCJzb21lIiwiciIsImlzU2luZ2xlUGFuZWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/optimization/cutCalculations.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Foptimize%2Froute&page=%2Fapi%2Foptimize%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Foptimize%2Froute.ts&appDir=%2FVolumes%2FT7%2Ferp_turinova_new%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FVolumes%2FT7%2Ferp_turinova_new&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();